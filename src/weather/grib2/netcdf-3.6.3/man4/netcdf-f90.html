<html lang="en">
<head>
<title>NetCDF Fortran 90 Interface Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="NetCDF Fortran 90 Interface Guide">
<meta name="generator" content="makeinfo 4.7">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 2005-2006 University Corporation for
Atmospheric Research


   Permission is granted to make and distribute verbatim copies of this
manual provided that the copyright notice and these paragraphs are
preserved on all copies.  The software and any accompanying written
materials are provided ``as is'' without warranty of any kind.  UCAR
expressly disclaims all warranties of any kind, either expressed or
implied, including but not limited to the implied warranties of
merchantability and fitness for a particular purpose.

The Unidata Program Center is managed by the University
Corporation for Atmospheric Research and sponsored by the National
Science Foundation.  Any opinions, findings, conclusions, or
recommendations expressed in this publication are those of the
author(s) and do not necessarily reflect the views of the National
Science Foundation.

Mention of any commercial company or product in this document
does not constitute an endorsement by the Unidata Program Center.
Unidata does not authorize any use of information from this
publication for advertising or publicity purposes.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc { font-variant:small-caps }
  span.roman { font-family: serif; font-weight: normal; } 
--></style>
</head>
<body>
<h1 class="settitle">NetCDF Fortran 90 Interface Guide</h1>
<div class="node">
<p><hr>
<a name="Top"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Use-of-the-NetCDF-Library">Use of the NetCDF Library</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>
<br>
</div>

<h2 class="unnumbered">The NetCDF Fortran 90 Interface Guide</h2>

<p>This document describes the Fortran 90 interface to the netCDF
library. It applies to netCDF version 3.6.3. This document
was last updated in 27 June 2008.

   <p>For a complete description of the netCDF format and utilities see
<a href="netcdf.html#Top">The NetCDF Users Guide (The NetCDF Users Guide)</a>.

<ul class="menu">
<li><a accesskey="1" href="#Use-of-the-NetCDF-Library">Use of the NetCDF Library</a>
<li><a accesskey="2" href="#Datasets">Datasets</a>
<li><a accesskey="3" href="#Groups">Groups</a>
<li><a accesskey="4" href="#Dimensions">Dimensions</a>
<li><a accesskey="5" href="#User-Defined-Data-Types">User Defined Data Types</a>
<li><a accesskey="6" href="#Variables">Variables</a>
<li><a accesskey="7" href="#Attributes">Attributes</a>
<li><a accesskey="8" href="#Summary-of-Fortran-90-Interface">Summary of Fortran 90 Interface</a>
<li><a accesskey="9" href="#FORTRAN-77-to-Fortran-90-Transition-Guide">FORTRAN 77 to Fortran 90 Transition Guide</a>
<li><a href="#Combined-Index">Combined Index</a>

</li></ul>
<p>--- The Detailed Node Listing ---

<p>Use of the NetCDF Library

</p>
<ul class="menu">
<li><a href="#Creating-a-NetCDF-Dataset">Creating a NetCDF Dataset</a>
<li><a href="#Reading-a-NetCDF-Dataset-with-Known-Names">Reading a NetCDF Dataset with Known Names</a>
<li><a href="#Reading-a-netCDF-Dataset-with-Unknown-Names">Reading a netCDF Dataset with Unknown Names</a>
<li><a href="#Writing-Data-in-an-Existing-NetCDF-Dataset">Writing Data in an Existing NetCDF Dataset</a>
<li><a href="#Adding-New-Dimensions">Adding New Dimensions</a>
<li><a href="#Error-Handling">Error Handling</a>
<li><a href="#Compiling-and-Linking-with-the-NetCDF-Library">Compiling and Linking with the NetCDF Library</a>

</li></ul>
<p>Datasets

</p>
<ul class="menu">
<li><a href="#Datasets-Introduction">Datasets Introduction</a>
<li><a href="#NetCDF-Library-Interface-Descriptions">NetCDF Library Interface Descriptions</a>
<li><a href="#NF90_005fSTRERROR">NF90_STRERROR</a>
<li><a href="#NF90_005fINQ_005fLIBVERS">NF90_INQ_LIBVERS</a>
<li><a href="#NF90_005fCREATE">NF90_CREATE</a>
<li><a href="#NF90_005fOPEN">NF90_OPEN</a>
<li><a href="#NF90_005fREDEF">NF90_REDEF</a>
<li><a href="#NF90_005fENDDEF">NF90_ENDDEF</a>
<li><a href="#NF90_005fCLOSE">NF90_CLOSE</a>
<li><a href="#NF90_005fINQUIRE-Family">NF90_INQUIRE Family</a>
<li><a href="#NF90_005fSYNC">NF90_SYNC</a>
<li><a href="#NF90_005fABORT">NF90_ABORT</a>
<li><a href="#NF90_005fSET_005fFILL">NF90_SET_FILL</a>

</li></ul>
<p>Groups

</p>
<ul class="menu">
<li><a href="#NF90_005fINQ_005fNCID">NF90_INQ_NCID</a>
<li><a href="#NF90_005fINQ_005fGRPS">NF90_INQ_GRPS</a>
<li><a href="#NF90_005fINQ_005fVARIDS">NF90_INQ_VARIDS</a>
<li><a href="#NF90_005fINQ_005fDIMIDS">NF90_INQ_DIMIDS</a>
<li><a href="#NF90_005fINQ_005fGRPNAME_005fLEN">NF90_INQ_GRPNAME_LEN</a>
<li><a href="#NF90_005fINQ_005fGRPNAME">NF90_INQ_GRPNAME</a>
<li><a href="#NF90_005fINQ_005fGRPNAME_005fFULL">NF90_INQ_GRPNAME_FULL</a>
<li><a href="#NF90_005fINQ_005fGRP_005fPARENT">NF90_INQ_GRP_PARENT</a>
<li><a href="#NF90_005fDEF_005fGRP">NF90_DEF_GRP</a>

</li></ul>
<p>Dimensions

</p>
<ul class="menu">
<li><a href="#Dimensions-Introduction">Dimensions Introduction</a>
<li><a href="#NF90_005fDEF_005fDIM">NF90_DEF_DIM</a>
<li><a href="#NF90_005fINQ_005fDIMID">NF90_INQ_DIMID</a>
<li><a href="#NF90_005fINQUIRE_005fDIMENSION">NF90_INQUIRE_DIMENSION</a>
<li><a href="#NF90_005fRENAME_005fDIM">NF90_RENAME_DIM</a>

</li></ul>
<p>User Defined Data Types

</p>
<ul class="menu">
<li><a href="#User-Defined-Types">User Defined Types</a>
<li><a href="#NF90_005fINQ_005fTYPEIDS">NF90_INQ_TYPEIDS</a>
<li><a href="#NF90_005fINQ_005fTYPE">NF90_INQ_TYPE</a>
<li><a href="#NF90_005fINQ_005fUSER_005fTYPE">NF90_INQ_USER_TYPE</a>
<li><a href="#Compound-Types">Compound Types</a>
<li><a href="#Variable-Length-Array">Variable Length Array</a>
<li><a href="#Opaque-Type">Opaque Type</a>
<li><a href="#Enum-Type">Enum Type</a>

</li></ul>
<p>Example

</p>
<ul class="menu">
<li><a href="#NF90_005fPUT_005fVLEN_005fELEMENT">NF90_PUT_VLEN_ELEMENT</a>
<li><a href="#NF90_005fGET_005fVLEN_005fELEMENT">NF90_GET_VLEN_ELEMENT</a>

</li></ul>
<p>Compound Types Introduction

</p>
<ul class="menu">
<li><a href="#NF90_005fDEF_005fCOMPOUND">NF90_DEF_COMPOUND</a>
<li><a href="#NF90_005fINSERT_005fCOMPOUND">NF90_INSERT_COMPOUND</a>
<li><a href="#NF90_005fINSERT_005fARRAY_005fCOMPOUND">NF90_INSERT_ARRAY_COMPOUND</a>
<li><a href="#NF90_005fINQ_005fCOMPOUND">NF90_INQ_COMPOUND</a>
<li><a href="#NF90_005fINQ_005fCOMPOUND_005fFIELD">NF90_INQ_COMPOUND_FIELD</a>

</li></ul>
<p>Variable Length Array Introduction

</p>
<ul class="menu">
<li><a href="#NF90_005fDEF_005fVLEN">NF90_DEF_VLEN</a>
<li><a href="#NF90_005fINQ_005fVLEN">NF90_INQ_VLEN</a>
<li><a href="#NF90_005fFREE_005fVLEN">NF90_FREE_VLEN</a>

</li></ul>
<p>Opaque Type Introduction

</p>
<ul class="menu">
<li><a href="#NF90_005fDEF_005fOPAQUE">NF90_DEF_OPAQUE</a>
<li><a href="#NF90_005fINQ_005fOPAQUE">NF90_INQ_OPAQUE</a>

</li></ul>
<p>Example

</p>
<ul class="menu">
<li><a href="#NF90_005fINQ_005fOPAQUE">NF90_INQ_OPAQUE</a>

</li></ul>
<p>Enum Type Introduction

</p>
<ul class="menu">
<li><a href="#NF90_005fDEF_005fENUM">NF90_DEF_ENUM</a>
<li><a href="#NF90_005fINSERT_005fENUM">NF90_INSERT_ENUM</a>
<li><a href="#NF90_005fINQ_005fENUM">NF90_INQ_ENUM</a>
<li><a href="#NF90_005fINQ_005fENUM_005fMEMBER">NF90_INQ_ENUM_MEMBER</a>
<li><a href="#NF90_005fINQ_005fENUM_005fIDENT">NF90_INQ_ENUM_IDENT</a>

</li></ul>
<p>Variables

</p>
<ul class="menu">
<li><a href="#Variables-Introduction">Variables Introduction</a>
<li><a href="#Language_002dTypes">Language-Types</a>
<li><a href="#NF90_005fDEF_005fVAR">NF90_DEF_VAR</a>:                 Create a Variable
<li><a href="#NF90_005fDEF_005fVAR_005fCHUNKING">NF90_DEF_VAR_CHUNKING</a>:        Set Var Chunking Parameters
<li><a href="#NF90_005fINQ_005fVAR_005fCHUNKING">NF90_INQ_VAR_CHUNKING</a>:        Get Var Chunking Parameters
<li><a href="#NF90_005fDEF_005fVAR_005fDEFLATE">NF90_DEF_VAR_DEFLATE</a>:         Set Var Compression Parameters
<li><a href="#NF90_005fINQ_005fVAR_005fDEFLATE">NF90_INQ_VAR_DEFLATE</a>:         Get Var Compression Parameters
<li><a href="#NF90_005fDEF_005fVAR_005fFLETCHER32">NF90_DEF_VAR_FLETCHER32</a>:      Set Var Fletcher32 Filter
<li><a href="#NF90_005fINQ_005fVAR_005fFLETCHER32">NF90_INQ_VAR_FLETCHER32</a>:      Get Var Fletcher32 Filter
<li><a href="#NF90_005fDEF_005fVAR_005fENDIAN">NF90_DEF_VAR_ENDIAN</a>:          Set Var Endianness
<li><a href="#NF90_005fINQ_005fVAR_005fENDIAN">NF90_INQ_VAR_ENDIAN</a>:          Get Var Endianness
<li><a href="#NF90_005fINQUIRE_005fVARIABLE">NF90_INQUIRE_VARIABLE</a>:        Get Var Metadata
<li><a href="#NF90_005fPUT_005fVAR">NF90_PUT_VAR</a>:                 Write data
<li><a href="#NF90_005fGET_005fVAR">NF90_GET_VAR</a>:                 Read data
<li><a href="#Reading-and-Writing-Character-String-Values">Reading and Writing Character String Values</a>
<li><a href="#Fill-Values">Fill Values</a>:                  What's Written Where there's No Data? 
<li><a href="#NF90_005fRENAME_005fVAR">NF90_RENAME_VAR</a>

</li></ul>
<p>Attributes

</p>
<ul class="menu">
<li><a href="#Attributes-Introduction">Attributes Introduction</a>
<li><a href="#Attribute-Conventions">Attribute Conventions</a>
<li><a href="#NF90_005fPUT_005fATT">NF90_PUT_ATT</a>
<li><a href="#NF90_005fINQUIRE_005fATTRIBUTE">NF90_INQUIRE_ATTRIBUTE</a>
<li><a href="#NF90_005fGET_005fATT">NF90_GET_ATT</a>
<li><a href="#NF90_005fCOPY_005fATT">NF90_COPY_ATT</a>
<li><a href="#NF90_005fRENAME_005fATT">NF90_RENAME_ATT</a>
<li><a href="#NF90_005fDEL_005fATT">NF90_DEL_ATT</a>

   </ul>

<div class="node">
<p><hr>
<a name="Use-of-the-NetCDF-Library"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Datasets">Datasets</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="chapter">1 Use of the NetCDF Library</h2>

<p><a name="index-users_0027-guide_002c-netcdf-1"></a><a name="index-common-netcdf-commands-2"></a>
You can use the netCDF library without knowing about all of the netCDF
interface. If you are creating a netCDF dataset, only a handful of
routines are required to define the necessary dimensions, variables,
and attributes, and to write the data to the netCDF dataset. (Even
less are needed if you use the ncgen utility to create the dataset
before running a program using netCDF library calls to write
data. See <a href="netcdf.html#ncgen">ncgen (NetCDF Users Guide)</a>.) 
Similarly, if you are writing software to access data stored in a
particular netCDF object, only a small subset of the netCDF library is
required to open the netCDF dataset and access the data. Authors of
generic applications that access arbitrary netCDF datasets need to be
familiar with more of the netCDF library.

   <p>In this chapter we provide templates of common sequences of netCDF
calls needed for common uses. For clarity we present only the names of
routines; omit declarations and error checking; omit the type-specific
suffixes of routine names for variables and attributes; indent
statements that are typically invoked multiple times; and use ... to
represent arbitrary sequences of other statements. Full parameter
lists are described in later chapters.

<ul class="menu">
<li><a accesskey="1" href="#Creating-a-NetCDF-Dataset">Creating a NetCDF Dataset</a>
<li><a accesskey="2" href="#Reading-a-NetCDF-Dataset-with-Known-Names">Reading a NetCDF Dataset with Known Names</a>
<li><a accesskey="3" href="#Reading-a-netCDF-Dataset-with-Unknown-Names">Reading a netCDF Dataset with Unknown Names</a>
<li><a accesskey="4" href="#Writing-Data-in-an-Existing-NetCDF-Dataset">Writing Data in an Existing NetCDF Dataset</a>
<li><a accesskey="5" href="#Adding-New-Dimensions">Adding New Dimensions</a>
<li><a accesskey="6" href="#Error-Handling">Error Handling</a>
<li><a accesskey="7" href="#Compiling-and-Linking-with-the-NetCDF-Library">Compiling and Linking with the NetCDF Library</a>
</ul>

<div class="node">
<p><hr>
<a name="Creating-a-NetCDF-Dataset"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Reading-a-NetCDF-Dataset-with-Known-Names">Reading a NetCDF Dataset with Known Names</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Use-of-the-NetCDF-Library">Use of the NetCDF Library</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Use-of-the-NetCDF-Library">Use of the NetCDF Library</a>
<br>
</div>

<h3 class="section">1.1 Creating a NetCDF Dataset</h3>

<p><a name="index-dataset_002c-creating-3"></a><a name="index-NF90_005fCREATE_002c-typical-use-4"></a><a name="index-NF90_005fDEF_005fDIM_002c-typical-use-5"></a><a name="index-NF90_005fDEF_005fVAR_002c-typical-use-6"></a><a name="index-NF90_005fPUT_005fATT_002c-typical-use-7"></a><a name="index-NF90_005fENDDEF_002c-typical-use-8"></a><a name="index-NF90_005fPUT_005fVAR_002c-typical-use-9"></a><a name="index-NF90_005fCLOSE_002c-typical-use-10"></a>
Here is a typical sequence of netCDF calls used to create a new netCDF
dataset:

<pre class="example">          NF90_CREATE           ! create netCDF dataset: enter define mode
               ...
             NF90_DEF_DIM       ! define dimensions: from name and length
               ...
             NF90_DEF_VAR       ! define variables: from name, type, dims
               ...
             NF90_PUT_ATT       ! assign attribute values
               ...
          NF90_ENDDEF           ! end definitions: leave define mode
               ...
             NF90_PUT_VAR       ! provide values for variable
               ...
          NF90_CLOSE            ! close: save new netCDF dataset
</pre>
   <p>Only one call is needed to create a netCDF dataset, at which point you
will be in the first of two netCDF modes. When accessing an open
netCDF dataset, it is either in define mode or data mode. In define
mode, you can create dimensions, variables, and new attributes, but
you cannot read or write variable data. In data mode, you can access
data and change existing attributes, but you are not permitted to
create new dimensions, variables, or attributes.

   <p>One call to NF90_DEF_DIM is needed for each dimension
created. Similarly, one call to NF90_DEF_VAR is needed for each
variable creation, and one call to a member of the NF90_PUT_ATT family
is needed for each attribute defined and assigned a value. To leave
define mode and enter data mode, call NF90_ENDDEF.

   <p>Once in data mode, you can add new data to variables, change old
values, and change values of existing attributes (so long as the
attribute changes do not require more storage space). Data of all
types is written to a netCDF variable using the NF90_PUT_VAR
subroutine. Single values, arrays, or array sections may be supplied
to NF90_PUT_VAR; optional arguments allow the writing of subsampled or
mapped portions of the variable. (Subsampled and mapped access are
general forms of data access that are explained later.)

   <p>Finally, you should explicitly close all netCDF datasets that have
been opened for writing by calling NF90_CLOSE. By default, access to
the file system is buffered by the netCDF library. If a program
terminates abnormally with netCDF datasets open for writing, your most
recent modifications may be lost. This default buffering of data is
disabled by setting the NF90_SHARE flag when opening the dataset. But
even if this flag is set, changes to attribute values or changes made
in define mode are not written out until NF90_SYNC or NF90_CLOSE is
called.

<div class="node">
<p><hr>
<a name="Reading-a-NetCDF-Dataset-with-Known-Names"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Reading-a-netCDF-Dataset-with-Unknown-Names">Reading a netCDF Dataset with Unknown Names</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Creating-a-NetCDF-Dataset">Creating a NetCDF Dataset</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Use-of-the-NetCDF-Library">Use of the NetCDF Library</a>
<br>
</div>

<h3 class="section">1.2 Reading a NetCDF Dataset with Known Names</h3>

<p><a name="index-NF90_005fOPEN_002c-typical-use-11"></a><a name="index-NF90_005fINQ_005fDIMID_002c-typical-use-12"></a><a name="index-NF90_005fINQ_005fVARID_002c-typical-use-13"></a><a name="index-NF90_005fGET_005fATT_002c-typical-use-14"></a><a name="index-NF90_005fGET_005fVAR_002c-typical-use-15"></a>
Here we consider the case where you know the names of not only the
netCDF datasets, but also the names of their dimensions, variables,
and attributes. (Otherwise you would have to do "inquire" calls.) The
order of typical C calls to read data from those variables in a netCDF
dataset is:

<pre class="example">          NF90_OPEN               ! open existing netCDF dataset
               ...
             NF90_INQ_DIMID       ! get dimension IDs
               ...
             NF90_INQ_VARID       ! get variable IDs
               ...
             NF90_GET_ATT         ! get attribute values
               ...
             NF90_GET_VAR         ! get values of variables
               ...
          NF90_CLOSE              ! close netCDF dataset
</pre>
   <p>First, a single call opens the netCDF dataset, given the dataset name,
and returns a netCDF ID that is used to refer to the open netCDF
dataset in all subsequent calls.

   <p>Next, a call to NF90_INQ_DIMID for each dimension of interest gets the
dimension ID from the dimension name. Similarly, each required
variable ID is determined from its name by a call to
NF90_INQ_VARID. Once variable IDs are known, variable attribute values
can be retrieved using the netCDF ID, the variable ID, and the desired
attribute name as input to NF90_GET_ATT for each desired
attribute. Variable data values can be directly accessed from the
netCDF dataset with calls to NF90_GET_VAR.

   <p>Finally, the netCDF dataset is closed with NF90_CLOSE. There is no
need to close a dataset open only for reading.

<div class="node">
<p><hr>
<a name="Reading-a-netCDF-Dataset-with-Unknown-Names"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Writing-Data-in-an-Existing-NetCDF-Dataset">Writing Data in an Existing NetCDF Dataset</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Reading-a-NetCDF-Dataset-with-Known-Names">Reading a NetCDF Dataset with Known Names</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Use-of-the-NetCDF-Library">Use of the NetCDF Library</a>
<br>
</div>

<h3 class="section">1.3 Reading a netCDF Dataset with Unknown Names</h3>

<p><a name="index-reading-dataset-with-unknown-names-16"></a><a name="index-NF90_005fINQUIRE_002c-typical-use-17"></a><a name="index-NF90_005fINQUIRE_005fDIMENSION_002c-typical-use-18"></a><a name="index-NF90_005fINQUIRE_005fVARIABLE_002c-typical-use-19"></a><a name="index-NF90_005fINQUIRE_005fATTRIBUTE_002c-typical-use-20"></a><a name="index-NF90_005fINQ_005fATTNAME_002c-typical-use-21"></a><a name="index-NF90_005fGET_005fATT_002c-typical-use-22"></a>
It is possible to write programs (e.g., generic software) which do
such things as processing every variable, without needing to know in
advance the names of these variables. Similarly, the names of
dimensions and attributes may be unknown.

   <p>Names and other information about netCDF objects may be obtained from
netCDF datasets by calling inquire functions. These return information
about a whole netCDF dataset, a dimension, a variable, or an
attribute. The following template illustrates how they are used:

<pre class="example">          NF90_OPEN                 ! open existing netCDF dataset
            ...
          NF90_INQUIRE              ! find out what is in it
               ...
             NF90_INQUIRE_DIMENSION ! get dimension names, lengths
               ...
             NF90_INQUIRE_VARIABLE  ! get variable names, types, shapes
                  ...
                NF90_INQ_ATTNAME    ! get attribute names
                  ...
                NF90_INQUIRE_ATTRIBUTE ! get other attribute information
                  ...
                NF90_GET_ATT        ! get attribute values
                  ...
             NF90_GET_VAR           ! get values of variables
               ...
          NF90_CLOSE                ! close netCDF dataset
</pre>
   <p>As in the previous example, a single call opens the existing netCDF
dataset, returning a netCDF ID. This netCDF ID is given to the
NF90_INQUIRE routine, which returns the number of dimensions, the
number of variables, the number of global attributes, and the ID of
the unlimited dimension, if there is one.

   <p>All the inquire functions are inexpensive to use and require no I/O,
since the information they provide is stored in memory when a netCDF
dataset is first opened.

   <p>Dimension IDs use consecutive integers, beginning at 1. Also
dimensions, once created, cannot be deleted. Therefore, knowing the
number of dimension IDs in a netCDF dataset means knowing all the
dimension IDs: they are the integers 1, 2, 3, ...up to the number of
dimensions. For each dimension ID, a call to the inquire function
NF90_INQUIRE_DIMENSION returns the dimension name and length.

   <p>Variable IDs are also assigned from consecutive integers 1, 2, 3,
... up to the number of variables. These can be used in
NF90_INQUIRE_VARIABLE calls to find out the names, types, shapes, and
the number of attributes assigned to each variable.

   <p>Once the number of attributes for a variable is known, successive
calls to NF90_INQ_ATTNAME return the name for each attribute given the
netCDF ID, variable ID, and attribute number. Armed with the attribute
name, a call to NF90_INQUIRE_ATTRIBUTE returns its type and
length. Given the type and length, you can allocate enough space to
hold the attribute values. Then a call to NF90_GET_ATT returns the
attribute values.

   <p>Once the IDs and shapes of netCDF variables are known, data values can
be accessed by calling NF90_GET_VAR.

<div class="node">
<p><hr>
<a name="Writing-Data-in-an-Existing-NetCDF-Dataset"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Adding-New-Dimensions">Adding New Dimensions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Reading-a-netCDF-Dataset-with-Unknown-Names">Reading a netCDF Dataset with Unknown Names</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Use-of-the-NetCDF-Library">Use of the NetCDF Library</a>
<br>
</div>

<h3 class="section">1.4 Writing Data in an Existing NetCDF Dataset</h3>

<p><a name="index-NF90_005fINQ_005fVARID_002c-typical-use-23"></a><a name="index-NF90_005fPUT_005fVAR_002c-typical-use-24"></a><a name="index-NF90_005fPUT_005fATT_002c-typical-use-25"></a><a name="index-writing-to-existing-dataset-26"></a>
With write access to an existing netCDF dataset, you can overwrite
data values in existing variables or append more data to record
variables along the unlimited (record) dimension. To append more data
to non-record variables requires changing the shape of such variables,
which means creating a new netCDF dataset, defining new variables with
the desired shape, and copying data. The netCDF data model was not
designed to make such "schema changes" efficient or easy, so it is
best to specify the shapes of variables correctly when you create a
netCDF dataset, and to anticipate which variables will later grow by
using the unlimited dimension in their definition.

   <p>The following code template lists a typical sequence of calls to
overwrite some existing values and add some new records to record
variables in an existing netCDF dataset with known variable names:

<pre class="example">          NF90_OPEN             ! open existing netCDF dataset
            ...
            NF90_INQ_VARID      ! get variable IDs
            ...
            NF90_PUT_VAR        ! provide new values for variables, if any
            ...
            NF90_PUT_ATT        ! provide new values for attributes, if any
              ...
          NF90_CLOSE            ! close netCDF dataset
</pre>
   <p>A netCDF dataset is first opened by the NF90_OPEN call. This call puts
the open dataset in data mode, which means existing data values can be
accessed and changed, existing attributes can be changed, but no new
dimensions, variables, or attributes can be added.

   <p>Next, calls to NF90_INQ_VARID get the variable ID from the name, for
each variable you want to write. Then each call to NF90_PUT_VAR writes
data into a specified variable, either a single value at a time, or a
whole set of values at a time, depending on which variant of the
interface is used. The calls used to overwrite values of non-record
variables are the same as are used to overwrite values of record
variables or append new data to record variables. The difference is
that, with record variables, the record dimension is extended by
writing values that don't yet exist in the dataset. This extends all
record variables at once, writing "fill values" for record variables
for which the data has not yet been written (but see <a href="#Fill-Values">Fill Values</a>
to specify different behavior).

   <p>Calls to NF90_PUT_ATT may be used to change the values of existing
attributes, although data that changes after a file is created is
typically stored in variables rather than attributes.

   <p>Finally, you should explicitly close any netCDF datasets into which
data has been written by calling NF90_CLOSE before program
termination. Otherwise, modifications to the dataset may be lost.

<div class="node">
<p><hr>
<a name="Adding-New-Dimensions"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Error-Handling">Error Handling</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Writing-Data-in-an-Existing-NetCDF-Dataset">Writing Data in an Existing NetCDF Dataset</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Use-of-the-NetCDF-Library">Use of the NetCDF Library</a>
<br>
</div>

<h3 class="section">1.5 Adding New Dimensions, Variables, Attributes</h3>

<p><a name="index-dimensions_002c-adding-27"></a><a name="index-variables_002c-adding-28"></a><a name="index-attributes_002c-adding-29"></a><a name="index-NF90_005fREDEF_002c-typical-use-30"></a>
An existing netCDF dataset can be extensively altered. New dimensions,
variables, and attributes can be added or existing ones renamed, and
existing attributes can be deleted. Existing dimensions, variables,
and attributes can be renamed. The following code template lists a
typical sequence of calls to add new netCDF components to an existing
dataset:

<pre class="example">          NF90_OPEN             ! open existing netCDF dataset
            ...
          NF90_REDEF            ! put it into define mode
              ...
            NF90_DEF_DIM        ! define additional dimensions (if any)
              ...
            NF90_DEF_VAR        ! define additional variables (if any)
              ...
            NF90_PUT_ATT        ! define other attributes (if any)
              ...
          NF90_ENDDEF           ! check definitions, leave define mode
              ...
            NF90_PUT_VAR        ! provide new variable values
              ...
          NF90_CLOSE            ! close netCDF dataset
</pre>
   <p>A netCDF dataset is first opened by the NF90_OPEN call. This call puts
the open dataset in data mode, which means existing data values can be
accessed and changed, existing attributes can be changed (so long as
they do not grow), but nothing can be added. To add new netCDF
dimensions, variables, or attributes you must enter define mode, by
calling NF90_REDEF. In define mode, call NF90_DEF_DIM to define new
dimensions, NF90_DEF_VAR to define new variables, and NF90_PUT_ATT to
assign new attributes to variables or enlarge old attributes.

   <p>You can leave define mode and reenter data mode, checking all the new
definitions for consistency and committing the changes to disk, by
calling NF90_ENDDEF. If you do not wish to reenter data mode, just
call NF90_CLOSE, which will have the effect of first calling
NF90_ENDDEF.

   <p>Until the NF90_ENDDEF call, you may back out of all the redefinitions
made in define mode and restore the previous state of the netCDF
dataset by calling NF90_ABORT. You may also use the NF90_ABORT call to
restore the netCDF dataset to a consistent state if the call to
NF90_ENDDEF fails. If you have called NF90_CLOSE from definition mode
and the implied call to NF90_ENDDEF fails, NF90_ABORT will
automatically be called to close the netCDF dataset and leave it in
its previous consistent state (before you entered define mode).

   <p>At most one process should have a netCDF dataset open for writing at
one time. The library is designed to provide limited support for
multiple concurrent readers with one writer, via disciplined use of
the NF90_SYNC function and the NF90_SHARE flag. If a writer makes
changes in define mode, such as the addition of new variables,
dimensions, or attributes, some means external to the library is
necessary to prevent readers from making concurrent accesses and to
inform readers to call NF90_SYNC before the next access.

<div class="node">
<p><hr>
<a name="Error-Handling"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Compiling-and-Linking-with-the-NetCDF-Library">Compiling and Linking with the NetCDF Library</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Adding-New-Dimensions">Adding New Dimensions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Use-of-the-NetCDF-Library">Use of the NetCDF Library</a>
<br>
</div>

<h3 class="section">1.6 Error Handling</h3>

<p><a name="index-error-handling-31"></a><a name="index-NF90_005fSTRERROR_002c-introduction-32"></a>
The netCDF library provides the facilities needed to handle errors in
a flexible way. Each netCDF function returns an integer status
value. If the returned status value indicates an error, you may handle
it in any way desired, from printing an associated error message and
exiting to ignoring the error indication and proceeding (not
recommended!). For simplicity, the examples in this guide check the
error status and call a separate function to handle any errors.

   <p>The NF90_STRERROR function is available to convert a returned integer
error status into an error message string.

   <p>Occasionally, low-level I/O errors may occur in a layer below the
netCDF library. For example, if a write operation causes you to exceed
disk quotas or to attempt to write to a device that is no longer
available, you may get an error from a layer below the netCDF library,
but the resulting write error will still be reflected in the returned
status value.

<div class="node">
<p><hr>
<a name="Compiling-and-Linking-with-the-NetCDF-Library"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#Error-Handling">Error Handling</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Use-of-the-NetCDF-Library">Use of the NetCDF Library</a>
<br>
</div>

<h3 class="section">1.7 Compiling and Linking with the NetCDF Library</h3>

<p><a name="index-linking-to-netCDF-library-33"></a><a name="index-compiling-with-netCDF-library-34"></a>
Details of how to compile and link a program that uses the netCDF C or
Fortran interfaces differ, depending on the operating system, the
available compilers, and where the netCDF library and include files
are installed.

   <p>Every Fortran 90 procedure or module which references netCDF constants
or procedures must have access to the module information created when
the netCDF module was compiled. The suffix for this file is &ldquo;MOD&rdquo;
(or sometimes &ldquo;mod&rdquo;).

   <p>Most F90 compilers allow the user to specify the location of .MOD
files, usually with the -I flag. (Some compilers, like absoft, use -p
instead).

<pre class="example">     f90 -c -I/usr/local/include mymodule.f90
</pre>
   <p>Starting with version 3.6.2, another method of building the netCDF
fortran libraries becomes available. With the
&ndash;enable-separate-fortran option to configure, the user can specify
that the C library should not contain the fortran functions. In these
cases an additional library, libnetcdff.a (not the extra &ldquo;f&rdquo;) will
be built. This library contains the fortran functions.

   <p>For more information about configure options, See <a href="netcdf-install.html#Specifying-the-Environment-for-Building">Specifying the Environment for Building (The NetCDF Installation and Porting Guide)</a>.

   <p>Building separate fortran libraries is required for shared library
builds, but is not done, by default, for static library builds.

   <p>When linking fortran programs without a separate fortran library,
programs must link to the netCDF library like this:

<pre class="example">     f90 -o myprogram myprogram.o -L/usr/local/netcdf/lib -lnetcdf
</pre>
   <div class="node">
<p><hr>
<a name="Datasets"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Groups">Groups</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Use-of-the-NetCDF-Library">Use of the NetCDF Library</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="chapter">2 Datasets</h2>

<ul class="menu">
<li><a accesskey="1" href="#Datasets-Introduction">Datasets Introduction</a>
<li><a accesskey="2" href="#NetCDF-Library-Interface-Descriptions">NetCDF Library Interface Descriptions</a>
<li><a accesskey="3" href="#NF90_005fSTRERROR">NF90_STRERROR</a>
<li><a accesskey="4" href="#NF90_005fINQ_005fLIBVERS">NF90_INQ_LIBVERS</a>
<li><a accesskey="5" href="#NF90_005fCREATE">NF90_CREATE</a>
<li><a accesskey="6" href="#NF90_005fOPEN">NF90_OPEN</a>
<li><a accesskey="7" href="#NF90_005fREDEF">NF90_REDEF</a>
<li><a accesskey="8" href="#NF90_005fENDDEF">NF90_ENDDEF</a>
<li><a accesskey="9" href="#NF90_005fCLOSE">NF90_CLOSE</a>
<li><a href="#NF90_005fINQUIRE-Family">NF90_INQUIRE Family</a>
<li><a href="#NF90_005fSYNC">NF90_SYNC</a>
<li><a href="#NF90_005fABORT">NF90_ABORT</a>
<li><a href="#NF90_005fSET_005fFILL">NF90_SET_FILL</a>
</ul>

<div class="node">
<p><hr>
<a name="Datasets-Introduction"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NetCDF-Library-Interface-Descriptions">NetCDF Library Interface Descriptions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Datasets">Datasets</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Datasets">Datasets</a>
<br>
</div>

<h3 class="section">2.1 Datasets Introduction</h3>

<p><a name="index-datasets_002c-overview-35"></a>
This chapter presents the interfaces of the netCDF functions that deal
with a netCDF dataset or the whole netCDF library.

   <p>A netCDF dataset that has not yet been opened can only be referred to
by its dataset name. Once a netCDF dataset is opened, it is referred
to by a netCDF ID, which is a small nonnegative integer returned when
you create or open the dataset. A netCDF ID is much like a file
descriptor in C or a logical unit number in FORTRAN. In any single
program, the netCDF IDs of distinct open netCDF datasets are
distinct. A single netCDF dataset may be opened multiple times and
will then have multiple distinct netCDF IDs; however at most one of
the open instances of a single netCDF dataset should permit
writing. When an open netCDF dataset is closed, the ID is no longer
associated with a netCDF dataset.

   <p>Functions that deal with the netCDF library include:
     <ul>
<li>Get version of library.

     <li>Get error message corresponding to a returned error code. 
</ul>

   <p>The operations supported on a netCDF dataset as a single object are:
     <ul>
<li>Create, given dataset name and whether to overwrite or not.

     <li>Open for access, given dataset name and read or write intent.

     <li>Put into define mode, to add dimensions, variables, or attributes.

     <li>Take out of define mode, checking consistency of additions.

     <li>Close, writing to disk if required.

     <li>Inquire about the number of dimensions, number of variables, number of
global attributes, and ID of the unlimited dimension, if any.

     <li>Synchronize to disk to make sure it is current.

     <li>Set and unset nofill mode for optimized sequential writes.

     <li>After a summary of conventions used in describing the netCDF
interfaces, the rest of this chapter presents a detailed description
of the interfaces for these operations. 
</ul>

<div class="node">
<p><hr>
<a name="NetCDF-Library-Interface-Descriptions"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fSTRERROR">NF90_STRERROR</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Datasets-Introduction">Datasets Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Datasets">Datasets</a>
<br>
</div>

<h3 class="section">2.2 NetCDF Library Interface Descriptions</h3>

<p><a name="index-interface-descriptions-36"></a>
Each interface description for a particular netCDF function in this
and later chapters contains:

     <ul>
<li>a description of the purpose of the function;

     <li>a Fortran 90 interface block that presents the type and order of the
formal parameters to the function;

     <li>a description of each formal parameter in the C interface;

     <li>a list of possible error conditions; and

     <li>an example of a Fortran 90 program fragment calling the netCDF
function (and perhaps other netCDF functions). 
</ul>

   <p>The examples follow a simple convention for error handling, always
checking the error status returned from each netCDF function call and
calling a handle_error function in case an error was detected. For an
example of such a function, see Section 5.2 "Get error message
corresponding to error status: nc_strerror".

<div class="node">
<p><hr>
<a name="NF90_005fSTRERROR"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQ_005fLIBVERS">NF90_INQ_LIBVERS</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NetCDF-Library-Interface-Descriptions">NetCDF Library Interface Descriptions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Datasets">Datasets</a>
<br>
</div>

<h3 class="section">2.3 NF90_STRERROR</h3>

<p><a name="index-NF90_005fSTRERROR-37"></a><a name="index-NF90_005fSTRERROR_002c-example-38"></a>
The function NF90_STRERROR returns a static reference to an error
message string corresponding to an integer netCDF error status or to a
system error number, presumably returned by a previous call to some
other netCDF function. The list of netCDF error status codes is
available in the appropriate include file for each language binding.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_strerror(ncerr)
        integer, intent( in) :: ncerr
        character(len = 80)  :: nf90_strerror
</pre>
     <dl>
<dt><code>NCERR</code><dd>An error status that might have been returned from a previous call to
some netCDF function. 
</dl>

<h3 class="heading">Errors</h3>

<p>If you provide an invalid integer error status that does not
correspond to any netCDF error message or or to any system error
message (as understood by the system strerror function), NF90_STRERROR
returns a string indicating that there is no such error status.

<h3 class="heading">Example</h3>

<p>Here is an example of a simple error handling function that uses
NF90_STRERROR to print the error message corresponding to the netCDF
error status returned from any netCDF function call and then exit:

<pre class="example">      subroutine handle_err(status)
        integer, intent ( in) :: status
     
        if(status /= nf90_noerr) then
          print *, trim(nf90_strerror(status))
          stop "Stopped"
        end if
      end subroutine handle_err
</pre>
   <div class="node">
<p><hr>
<a name="NF90_005fINQ_005fLIBVERS"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fCREATE">NF90_CREATE</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fSTRERROR">NF90_STRERROR</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Datasets">Datasets</a>
<br>
</div>

<h3 class="section">2.4 Get netCDF library version: NF90_INQ_LIBVERS</h3>

<p><a name="index-NF90_005fINQ_005fLIBVERS-39"></a><a name="index-NF90_005fINQ_005fLIBVERS_002c-example-40"></a>
The function NF90_INQ_LIBVERS returns a string identifying the version
of the netCDF library, and when it was built.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_inq_libvers()
        character(len = 80) :: nf90_inq_libvers
</pre>
<h3 class="heading">Errors</h3>

<p>This function takes no arguments, and returns no error status.

<h3 class="heading">Example</h3>

<p>Here is an example using nc_inq_libvers to print the version of the
netCDF library with which the program is linked:

<pre class="example">      print *, trim(nf90_inq_libvers())
</pre>
   <div class="node">
<p><hr>
<a name="NF90_005fCREATE"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fOPEN">NF90_OPEN</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQ_005fLIBVERS">NF90_INQ_LIBVERS</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Datasets">Datasets</a>
<br>
</div>

<h3 class="section">2.5 NF90_CREATE</h3>

<p><a name="index-NF90_005fCREATE-41"></a><a name="index-NF90_005fCREATE-_002c-example-42"></a>
This function creates a new netCDF dataset, returning a netCDF ID that
can subsequently be used to refer to the netCDF dataset in other
netCDF function calls. The new netCDF dataset opened for write access
and placed in define mode, ready for you to add dimensions, variables,
and attributes.

   <p>A creation mode flag specifies whether to overwrite any existing
dataset with the same name and whether access to the dataset is
shared.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_create(path, cmode, ncid)
        character (len = *), intent(in   ) :: path
        integer,             intent(in   ) :: cmode
        integer, optional,   intent(in   ) :: initialsize
        integer, optional,   intent(inout) :: chunksize
        integer,             intent(  out) :: ncid
        integer                            :: nf90_create
</pre>
     <dl>
<dt><code>path</code><dd>The file name of the new netCDF dataset.

     <br><dt><code>cmode</code><dd>The creation mode flag. The following flags are available:
NF90_NOCLOBBER, NF90_SHARE, NF90_64BIT_OFFSET, NF90_HDF5, and
NF90_CLASSIC_MODEL.

     <p>A zero value (defined for convenience as NF90_CLOBBER) specifies the
default behavior: overwrite any existing dataset with the same file
name and buffer and cache accesses for efficiency. The dataset will be
in netCDF classic format. See <a href="netcdf.html#NetCDF-Classic-Format-Limitations">NetCDF Classic Format Limitations (NetCDF Users' Guide)</a>.

     <p>Setting NF90_NOCLOBBER means you do not want to clobber (overwrite) an
existing dataset; an error (NF90_EEXIST) is returned if the specified
dataset already exists.

     <p>The NF90_SHARE flag is appropriate when one process may be writing the
dataset and one or more other processes reading the dataset
concurrently; it means that dataset accesses are not buffered and
caching is limited. Since the buffering scheme is optimized for
sequential access, programs that do not access data sequentially may
see some performance improvement by setting the NF90_SHARE flag. (This
only applies to netCDF-3 classic or 64-bit offset files.)

     <p>Setting NF90_64BIT_OFFSET causes netCDF to create a 64-bit offset format
file, instead of a netCDF classic format file. The 64-bit offset
format imposes far fewer restrictions on very large (i.e. over 2 GB)
data files. See <a href="netcdf.html#Large-File-Support">Large File Support (NetCDF Users' Guide)</a>.

     <p>Setting the NF90_HDF5 flag causes netCDF to create a netCDF-4/HDF5
format output file.

     <p>Oring the NF90_CLASSIC_MODEL flag with the NF90_HDF5 flag causes the
resulting netCDF-4/HDF5 file to restrict itself to the classic model -
none of the new netCDF-4 data model features, such as groups or
user-defined types, are allowed in such a file.

     <br><dt><code>ncid</code><dd>Returned netCDF ID. 
</dl>

   <p>The following optional arguments allow additional performance tuning.

     <dl>
<dt><code>initialsize</code><dd>The initial size of the file (in bytes) at creation time. A value of 0
causes the file size to be computed when nf90_enddef is called. This
is ignored for NetCDF-4/HDF5 files.

     <br><dt><code>chunksize</code><dd>Controls a space versus time trade-off, memory allocated in the netcdf
library versus number of system calls. Because of internal
requirements, the value may not be set to exactly the value
requested. The actual value chosen is returned.

     <p>The library chooses a system-dependent default value if
NF90_SIZEHINT_DEFAULT is supplied as input. If the "preferred I/O
block size" is available from the stat() system call as member
st_blksize this value is used. Lacking that, twice the system pagesize
is used. Lacking a call to discover the system pagesize, the default
chunksize is set to 8192 bytes.

     <p>The chunksize is a property of a given open netcdf descriptor ncid, it
is not a persistent property of the netcdf dataset.

     <p>This is ignored for NetCDF-4/HDF5 files. 
</dl>

<h3 class="heading">Errors</h3>

<p>NF90_CREATE returns the value NF90_NOERR if no errors occurred. Possible
causes of errors include:
     <ul>
<li>Passing a dataset name that includes a directory that does not exist. 
<li>Specifying a dataset name of a file that exists and also specifying
NF90_NOCLOBBER. 
<li>Specifying a meaningless value for the creation mode. 
<li>Attempting to create a netCDF dataset in a directory where you don't
have permission to create files. 
</ul>

<h3 class="heading">Example</h3>

<p>In this example we create a netCDF dataset named foo.nc; we want the
dataset to be created in the current directory only if a dataset with
that name does not already exist:

<pre class="example">      use netcdf
      implicit none
      integer :: ncid, status
      ...
      status = nf90_create(path = "foo.nc", cmode = nf90_noclobber, ncid = ncid)
      if (status /= nf90_noerr) call handle_err(status)
</pre>
   <div class="node">
<p><hr>
<a name="NF90_005fOPEN"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fREDEF">NF90_REDEF</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fCREATE">NF90_CREATE</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Datasets">Datasets</a>
<br>
</div>

<h3 class="section">2.6 NF90_OPEN</h3>

<p><a name="index-NF90_005fOPEN-43"></a><a name="index-NF90_005fOPEN-_002c-example-44"></a>
The function NF90_OPEN opens an existing netCDF dataset for access.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_open(path, mode, ncid, chunksize)
        character (len = *), intent(in   ) :: path
        integer,             intent(in   ) :: mode
        integer,             intent(  out) :: ncid
        integer, optional,   intent(inout) :: chunksize
        integer                            :: nf90_open
</pre>
     <dl>
<dt><code>path</code><dd>File name for netCDF dataset to be opened.

     <br><dt><code>omode</code><dd>A zero value (or NF90_NOWRITE) specifies the default behavior: open the
dataset with read-only access, buffering and caching accesses for
efficiency

     <p>Otherwise, the creation mode is NF90_WRITE, NF90_SHARE, or
NF90_WRITE|NF90_SHARE. Setting the NF90_WRITE flag opens the dataset with
read-write access. ("Writing" means any kind of change to the dataset,
including appending or changing data, adding or renaming dimensions,
variables, and attributes, or deleting attributes.) The NF90_SHARE flag
is appropriate when one process may be writing the dataset and one or
more other processes reading the dataset concurrently; it means that
dataset accesses are not buffered and caching is limited. Since the
buffering scheme is optimized for sequential access, programs that do
not access data sequentially may see some performance improvement by
setting the NF90_SHARE flag.

     <br><dt><code>ncid</code><dd>Returned netCDF ID. 
</dl>

   <p>The following optional argument allows additional performance tuning.

     <dl>
<dt><code>chunksize</code><dd>Controls a space versus time trade-off, memory allocated in the netcdf
library versus number of system calls. Because of internal
requirements, the value may not be set to exactly the value
requested. The actual value chosen is returned.

     <p>The library chooses a system-dependent default value if
NF90_SIZEHINT_DEFAULT is supplied as input. If the "preferred I/O
block size" is available from the stat() system call as member
st_blksize this value is used. Lacking that, twice the system pagesize
is used. Lacking a call to discover the system pagesize, the default
chunksize is set to 8192 bytes.

     <p>The chunksize is a property of a given open netcdf descriptor ncid, it
is not a persistent property of the netcdf dataset. 
</dl>

<h3 class="heading">Errors</h3>

<p>NF90_OPEN returns the value NF90_NOERR if no errors occurred. Otherwise,
the returned status indicates an error. Possible causes of errors
include:
     <ul>
<li>The specified netCDF dataset does not exist. 
<li>A meaningless mode was specified. 
</ul>

<h3 class="heading">Example</h3>

<p>Here is an example using NF90_OPEN to open an existing netCDF dataset
named foo.nc for read-only, non-shared access:

<pre class="example">      use netcdf
      implicit none
      integer :: ncid, status
      ...
      status = nf90_open(path = "foo.nc", cmode = nf90_nowrite, ncid = ncid)
      if (status /= nf90_noerr) call handle_err(status)
</pre>
   <div class="node">
<p><hr>
<a name="NF90_005fREDEF"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fENDDEF">NF90_ENDDEF</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fOPEN">NF90_OPEN</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Datasets">Datasets</a>
<br>
</div>

<h3 class="section">2.7 NF90_REDEF</h3>

<p><a name="index-NF90_005fREDEF-45"></a><a name="index-NF90_005fREDEF-_002c-example-46"></a>
The function NF90_REDEF puts an open netCDF dataset into define mode, so
dimensions, variables, and attributes can be added or renamed and
attributes can be deleted.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_redef(ncid)
        integer, intent( in) :: ncid
        integer              :: nf90_redef
</pre>
     <dl>
<dt><code>ncid</code><dd>netCDF ID, from a previous call to NF90_OPEN or NF90_CREATE. 
</dl>

<h3 class="heading">Errors</h3>

<p>NF90_REDEF returns the value NF90_NOERR if no errors occurred. Otherwise,
the returned status indicates an error. Possible causes of errors
include:
     <ul>
<li>The specified netCDF dataset is already in define mode.

     <li>The specified netCDF dataset was opened for read-only.

     <li>The specified netCDF ID does not refer to an open netCDF dataset. 
</ul>

<h3 class="heading">Example</h3>

<p>Here is an example using NF90_REDEF to open an existing netCDF dataset
named foo.nc and put it into define mode:

<pre class="example">      use netcdf
      implicit none
      integer :: ncid, status
      ...
      status = nf90_open("foo.nc", nf90_write, ncid) ! Open dataset
      if (status /= nf90_noerr) call handle_err(status)
      ...
      status = nf90_redef(ncid)                       ! Put the file in define mode
      if (status /= nf90_noerr) call handle_err(status)
</pre>
   <div class="node">
<p><hr>
<a name="NF90_005fENDDEF"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fCLOSE">NF90_CLOSE</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fREDEF">NF90_REDEF</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Datasets">Datasets</a>
<br>
</div>

<h3 class="section">2.8 NF90_ENDDEF</h3>

<p><a name="index-NF90_005fENDDEF-47"></a><a name="index-NF90_005fENDDEF-_002c-example-48"></a>
The function NF90_ENDDEF takes an open netCDF dataset out of define
mode. The changes made to the netCDF dataset while it was in define
mode are checked and committed to disk if no problems
occurred. Non-record variables may be initialized to a "fill value" as
well (see <a href="#NF90_005fSET_005fFILL">NF90_SET_FILL</a>). The netCDF dataset is then placed in
data mode, so variable data can be read or written.

   <p>This call may involve copying data under some circumstances. For a
more extensive discussion See <a href="netcdf.html#File-Structure-and-Performance">File Structure and Performance (NetCDF Users Guide)</a>.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_enddef(ncid, h_minfree, v_align, v_minfree, r_align)
        integer,           intent( in) :: ncid
        integer, optional, intent( in) :: h_minfree, v_align, v_minfree, r_align
        integer                        :: nf90_enddef
</pre>
     <dl>
<dt><code>ncid</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE. 
</dl>

   <p>The following arguments allow additional performance tuning. Note:
these arguments expose internals of the netcdf version 1 file format,
and may not be available in future netcdf implementations.

   <p>The current netcdf file format has three sections: the "header"
section, the data section for fixed size variables, and the data
section for variables which have an unlimited dimension (record
variables). The header begins at the beginning of the file. The index
(offset) of the beginning of the other two sections is contained in
the header. Typically, there is no space between the sections. This
causes copying overhead to accrue if one wishes to change the size of
the sections, as may happen when changing the names of things, text
attribute values, adding attributes or adding variables. Also, for
buffered i/o, there may be advantages to aligning sections in certain
ways.

   <p>The minfree parameters allow one to control costs of future calls to
nf90_redef or nf90_enddef by requesting that some space be available
at the end of the section. The default value for both h_minfree and
v_minfree is 0.

   <p>The align parameters allow one to set the alignment of the beginning
of the corresponding sections. The beginning of the section is rounded
up to an index which is a multiple of the align parameter. The flag
value NF90_ALIGN_CHUNK tells the library to use the chunksize (see
above) as the align parameter. The default value for both v_align and
r_align is 4 bytes.

     <dl>
<dt><code>h_minfree</code><dd>Size of the pad (in bytes) at the end of the "header" section.

     <br><dt><code>v_minfree</code><dd>Size of the pad (in bytes) at the end of the data section for fixed
size variables.

     <br><dt><code>v_align</code><dd>The alignment of the beginning of the data section for fixed size
variables.

     <br><dt><code>r_align</code><dd>The alignment of the beginning of the data section for variables which
have an unlimited dimension (record variables).

   </dl>

<h3 class="heading">Errors</h3>

<p>NF90_ENDDEF returns the value NF90_NOERR if no errors occurred. Otherwise,
the returned status indicates an error. Possible causes of errors
include:
     <ul>
<li>The specified netCDF dataset is not in define mode.

     <li>The specified netCDF ID does not refer to an open netCDF dataset.

     <li>The size of one or more variables exceed the size constraints for
whichever variant of the file format is in use). 
See <a href="netcdf.html#Large-File-Support">Large File Support (The NetCDF Users Guide)</a>. 
</ul>

<h3 class="heading">Example</h3>

<p>Here is an example using NF90_ENDDEF to finish the definitions of a new
netCDF dataset named foo.nc and put it into data mode:

<pre class="example">      use netcdf
      implicit none
      integer :: ncid, status
      ...
      status = nf90_create("foo.nc", nf90_noclobber, ncid)
      if (status /= nf90_noerr) call handle_err(status)
      ...  !  create dimensions, variables, attributes
      status = nf90_enddef(ncid)
      if (status /= nf90_noerr) call handle_err(status)
</pre>
   <div class="node">
<p><hr>
<a name="NF90_005fCLOSE"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQUIRE-Family">NF90_INQUIRE Family</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fENDDEF">NF90_ENDDEF</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Datasets">Datasets</a>
<br>
</div>

<h3 class="section">2.9 NF90_CLOSE</h3>

<p><a name="index-NF90_005fCLOSE-49"></a><a name="index-NF90_005fCLOSE-_002c-example-50"></a>
The function NF90_CLOSE closes an open netCDF dataset. If the dataset is
in define mode, NF90_ENDDEF will be called before closing. (In this
case, if NF90_ENDDEF returns an error, NF90_ABORT will automatically be
called to restore the dataset to the consistent state before define
mode was last entered.) After an open netCDF dataset is closed, its
netCDF ID may be reassigned to the next netCDF dataset that is opened
or created.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_close(ncid)
        integer, intent( in) :: ncid
        integer              :: nf90_close
</pre>
     <dl>
<dt><code>ncid</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE. 
</dl>

<h3 class="heading">Errors</h3>

<p>NF90_CLOSE returns the value NF90_NOERR if no errors occurred. Otherwise,
the returned status indicates an error. Possible causes of errors
include:
     <ul>
<li>Define mode was entered and the automatic call made to NF90_ENDDEF
failed.

     <li>The specified netCDF ID does not refer to an open netCDF dataset. 
</ul>

<h3 class="heading">Example</h3>

<p>Here is an example using NF90_CLOSE to finish the definitions of a new
netCDF dataset named foo.nc and release its netCDF ID:

<pre class="example">      use netcdf
      implicit none
      integer :: ncid, status
      ...
      status = nf90_create("foo.nc", nf90_noclobber, ncid)
      if (status /= nf90_noerr) call handle_err(status)
      ...  !  create dimensions, variables, attributes
      status = nf90_close(ncid)
      if (status /= nf90_noerr) call handle_err(status)
</pre>
   <div class="node">
<p><hr>
<a name="NF90_005fINQUIRE-Family"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fSYNC">NF90_SYNC</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fCLOSE">NF90_CLOSE</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Datasets">Datasets</a>
<br>
</div>

<h3 class="section">2.10 NF90_INQUIRE Family</h3>

<p>The NF90_INQUIRE subroutine returns information about an open netCDF
dataset, given its netCDF ID. The subroutine can be called from either
define mode or data mode, and returns values for any or all of the
following: the number of dimensions, the number of variables, the
number of global attributes, and the dimension ID of the dimension
defined with unlimited length, if any.    An additional function,
NF90_INQ_FORMAT, returns the (rarely needed) format version.

   <p>No I/O is performed when NF90_INQUIRE is called, since the required
information is available in memory for each open netCDF dataset.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_inquire(ncid, nDimensions, nVariables, nAttributes, &amp;
                            unlimitedDimId, formatNum)
        integer,           intent( in) :: ncid
        integer, optional, intent(out) :: nDimensions, nVariables, &amp;
                                          nAttributes, unlimitedDimId, &amp;
                                          formatNum
        integer                        :: nf90_inquire
</pre>
     <dl>
<dt><code>ncid</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>nDimensions</code><dd>Returned number of dimensions defined for this netCDF dataset.

     <br><dt><code>nVariables</code><dd>Returned number of variables defined for this netCDF dataset.

     <br><dt><code>nAttributes</code><dd>Returned number of global attributes defined for this netCDF dataset.

     <br><dt><code>unlimitedDimID</code><dd>Returned ID of the unlimited dimension, if there is one for this
netCDF dataset. If no unlimited length dimension has been defined, -1
is returned.

     <br><dt><code>format</code><dd>Returned integer indicating format version for this dataset, one of
nf90_format_classic,
nf90_format_64bit,
nf90_format_netcdf4, or
nf90_format_netcdf4_classic.  These are rarely needed by users or
applications, since thhe library recognizes the format of a file it is
accessing and handles it accordingly. 
</dl>

<h3 class="heading">Errors</h3>

<p>Function NF90_INQUIRE returns the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:

     <ul>
<li>The specified netCDF ID does not refer to an open netCDF dataset. 
</ul>

<h3 class="heading">Example</h3>

<p>Here is an example using NF90_INQUIRE to find out about a netCDF dataset
named foo.nc:

<pre class="example">      use netcdf
      implicit none
      integer :: ncid, status, nDims, nVars, nGlobalAtts, unlimDimID
      ...
      status = nf90_open("foo.nc", nf90_nowrite, ncid)
      if (status /= nf90_noerr) call handle_err(status)
      ...
      status = nf90_inquire(ncid, nDims, nVars, nGlobalAtts, unlimdimid)
      if (status /= nf90_noerr) call handle_err(status)
      status = nf90_inquire(ncid, nDimensions = nDims, &amp;
                            unlimitedDimID = unlimdimid)
      if (status /= nf90_noerr) call handle_err(status)
</pre>
   <div class="node">
<p><hr>
<a name="NF90_005fSYNC"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fABORT">NF90_ABORT</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQUIRE-Family">NF90_INQUIRE Family</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Datasets">Datasets</a>
<br>
</div>

<h3 class="section">2.11 NF90_SYNC</h3>

<p><a name="index-NF90_005fSYNC-51"></a><a name="index-NF90_005fSYNC-_002c-example-52"></a>
The function NF90_SYNC offers a way to synchronize the disk copy of a
netCDF dataset with in-memory buffers. There are two reasons you might
want to synchronize after writes:
     <ul>
<li>To minimize data loss in case of abnormal termination, or

     <li>To make data available to other processes for reading immediately
after it is written. But note that a process that already had the
dataset open for reading would not see the number of records increase
when the writing process calls NF90_SYNC; to accomplish this, the
reading process must call NF90_SYNC. 
</ul>

   <p>This function is backward-compatible with previous versions of the
netCDF library. The intent was to allow sharing of a netCDF dataset
among multiple readers and one writer, by having the writer call
NF90_SYNC after writing and the readers call NF90_SYNC before each
read. For a writer, this flushes buffers to disk. For a reader, it
makes sure that the next read will be from disk rather than from
previously cached buffers, so that the reader will see changes made by
the writing process (e.g., the number of records written) without
having to close and reopen the dataset. If you are only accessing a
small amount of data, it can be expensive in computer resources to
always synchronize to disk after every write, since you are giving up
the benefits of buffering.

   <p>An easier way to accomplish sharing (and what is now recommended) is
to have the writer and readers open the dataset with the NF90_SHARE
flag, and then it will not be necessary to call NF90_SYNC at
all. However, the NF90_SYNC function still provides finer granularity
than the NF90_SHARE flag, if only a few netCDF accesses need to be
synchronized among processes.

   <p>It is important to note that changes to the ancillary data, such as
attribute values, are not propagated automatically by use of the
NF90_SHARE flag. Use of the NF90_SYNC function is still required for
this purpose.

   <p>Sharing datasets when the writer enters define mode to change the data
schema requires extra care. In previous releases, after the writer
left define mode, the readers were left looking at an old copy of the
dataset, since the changes were made to a new copy. The only way
readers could see the changes was by closing and reopening the
dataset. Now the changes are made in place, but readers have no
knowledge that their internal tables are now inconsistent with the new
dataset schema. If netCDF datasets are shared across redefinition,
some mechanism external to the netCDF library must be provided that
prevents access by readers during redefinition and causes the readers
to call NF90_SYNC before any subsequent access.

   <p>When calling NF90_SYNC, the netCDF dataset must be in data mode. A
netCDF dataset in define mode is synchronized to disk only when
NF90_ENDDEF is called. A process that is reading a netCDF dataset that
another process is writing may call NF90_SYNC to get updated with the
changes made to the data by the writing process (e.g., the number of
records written), without having to close and reopen the dataset.

   <p>Data is automatically synchronized to disk when a netCDF dataset is
closed, or whenever you leave define mode.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_sync(ncid)
        integer, intent( in) :: ncid
        integer              :: nf90_sync
</pre>
     <dl>
<dt><code>ncid</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE. 
</dl>

<h3 class="heading">Errors</h3>

<p>NF90_SYNC returns the value NF90_NOERR if no errors occurred. Otherwise,
the returned status indicates an error. Possible causes of errors
include:
     <ul>
<li>The netCDF dataset is in define mode.

     <li>The specified netCDF ID does not refer to an open netCDF dataset. 
</ul>

<h3 class="heading">Example</h3>

<p>Here is an example using NF90_SYNC to synchronize the disk writes of a
netCDF dataset named foo.nc:

<pre class="example">      use netcdf
      implicit none
      integer :: ncid, status
      ...
      status = nf90_open("foo.nc", nf90_write, ncid)
      if (status /= nf90_noerr) call handle_err(status)
      ...
      ! write data or change attributes
      ...
      status = NF90_SYNC(ncid)
      if (status /= nf90_noerr) call handle_err(status)
</pre>
   <div class="node">
<p><hr>
<a name="NF90_005fABORT"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fSET_005fFILL">NF90_SET_FILL</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fSYNC">NF90_SYNC</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Datasets">Datasets</a>
<br>
</div>

<h3 class="section">2.12 NF90_ABORT</h3>

<p><a name="index-NF90_005fABORT-53"></a><a name="index-NF90_005fABORT-_002c-example-54"></a>
You no longer need to call this function, since it is called
automatically by NF90_CLOSE in case the dataset is in define mode and
something goes wrong with committing the changes. The function
NF90_ABORT just closes the netCDF dataset, if not in define mode. If the
dataset is being created and is still in define mode, the dataset is
deleted. If define mode was entered by a call to NF90_REDEF, the netCDF
dataset is restored to its state before definition mode was entered
and the dataset is closed.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_abort(ncid)
        integer, intent( in) :: ncid
        integer              :: nf90_abort
</pre>
     <dl>
<dt><code>ncid</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE. 
</dl>

<h3 class="heading">Errors</h3>

<p>NF90_ABORT returns the value NF90_NOERR if no errors occurred. Otherwise,
the returned status indicates an error. Possible causes of errors
include:
     <ul>
<li>When called from define mode while creating a netCDF dataset, deletion
of the dataset failed.

     <li>The specified netCDF ID does not refer to an open netCDF dataset. 
</ul>

<h3 class="heading">Example</h3>

<p>Here is an example using NF90_ABORT to back out of redefinitions of a
dataset named foo.nc:

<pre class="example">      use netcdf
      implicit none
      integer :: ncid, status, LatDimID
      ...
      status = nf90_open("foo.nc", nf90_write, ncid)
      if (status /= nf90_noerr) call handle_err(status)
      ...
      status = nf90_redef(ncid)
      if (status /= nf90_noerr) call handle_err(status)
      ...
      status = nf90_def_dim(ncid, "Lat", 18, LatDimID)
      if (status /= nf90_noerr) then ! Dimension definition failed
        call handle_err(status)
        status = nf90_abort(ncid) ! Abort redefinitions
        if (status /= nf90_noerr) call handle_err(status)
      end if
     ...
</pre>
   <div class="node">
<p><hr>
<a name="NF90_005fSET_005fFILL"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fABORT">NF90_ABORT</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Datasets">Datasets</a>
<br>
</div>

<h3 class="section">2.13 NF90_SET_FILL</h3>

<p><a name="index-NF90_005fSET_005fFILL-55"></a><a name="index-NF90_005fSET_005fFILL-_002c-example-56"></a>
This function is intended for advanced usage, to optimize writes under
some circumstances described below. The function NF90_SET_FILL sets the
fill mode for a netCDF dataset open for writing and returns the
current fill mode in a return parameter. The fill mode can be
specified as either NF90_FILL or NF90_NOFILL. The default behavior
corresponding to NF90_FILL is that data is pre-filled with fill values,
that is fill values are written when you create non-record variables
or when you write a value beyond data that has not yet been
written. This makes it possible to detect attempts to read data before
it was written. See <a href="#Fill-Values">Fill Values</a>, for more information on the use of
fill values. See <a href="#Attribute-Conventions">Attribute Conventions</a>, for information about how
to define your own fill values.

   <p>The behavior corresponding to NF90_NOFILL overrides the default behavior
of prefilling data with fill values. This can be used to enhance
performance, because it avoids the duplicate writes that occur when
the netCDF library writes fill values that are later overwritten with
data.

   <p>A value indicating which mode the netCDF dataset was already in is
returned. You can use this value to temporarily change the fill mode
of an open netCDF dataset and then restore it to the previous mode.

   <p>After you turn on NF90_NOFILL mode for an open netCDF dataset, you must
be certain to write valid data in all the positions that will later be
read. Note that nofill mode is only a transient property of a netCDF
dataset open for writing: if you close and reopen the dataset, it will
revert to the default behavior. You can also revert to the default
behavior by calling NF90_SET_FILL again to explicitly set the fill mode
to NF90_FILL.

   <p>There are three situations where it is advantageous to set nofill
mode:
     <ol type=1 start=1>
<li>Creating and initializing a netCDF dataset. In this case, you should
set nofill mode before calling NF90_ENDDEF and then write completely all
non-record variables and the initial records of all the record
variables you want to initialize. 
<li>Extending an existing record-oriented netCDF dataset. Set nofill mode
after opening the dataset for writing, then append the additional
records to the dataset completely, leaving no intervening unwritten
records. 
<li>Adding new variables that you are going to initialize to an existing
netCDF dataset. Set nofill mode before calling NF90_ENDDEF then write
all the new variables completely.
        </ol>

   <p>If the netCDF dataset has an unlimited dimension and the last record
was written while in nofill mode, then the dataset may be shorter than
if nofill mode was not set, but this will be completely transparent if
you access the data only through the netCDF interfaces.

   <p>The use of this feature may not be available (or even needed) in
future releases. Programmers are cautioned against heavy reliance upon
this feature.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_set_fill(ncid, fillmode, old_mode)
        integer, intent( in) :: ncid, fillmode
        integer, intent(out) :: old_mode
        integer              :: nf90_set_fill
</pre>
     <dl>
<dt><code>ncid</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>fillmode</code><dd>Desired fill mode for the dataset, either NF90_NOFILL or NF90_FILL.

     <br><dt><code>old_mode</code><dd>Returned current fill mode of the dataset before this call, either
NF90_NOFILL or NF90_FILL. 
</dl>

<h3 class="heading">Errors</h3>

<p>NF90_SET_FILL returns the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
     <ul>
<li>The specified netCDF ID does not refer to an open netCDF dataset.

     <li>The specified netCDF ID refers to a dataset open for read-only access.

     <li>The fill mode argument is neither NF90_NOFILL nor NF90_FILL.. 
</ul>

<h3 class="heading">Example</h3>

<p>Here is an example using NF90_SET_FILL to set nofill mode for subsequent
writes of a netCDF dataset named foo.nc:

<pre class="example">      use netcdf
      implicit none
      integer :: ncid, status, oldMode
      ...
      status = nf90_open("foo.nc", nf90_write, ncid)
      if (status /= nf90_noerr) call handle_err(status)
      ...
      ! Write data with prefilling behavior
      ...
      status = nf90_set_fill(ncid, nf90_nofill, oldMode)
      if (status /= nf90_noerr) call handle_err(status)
      ...
      !  Write data with no prefilling
      ...
</pre>
   <div class="node">
<p><hr>
<a name="Groups"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Dimensions">Dimensions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Datasets">Datasets</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="chapter">3 Groups</h2>

<p><a name="index-groups_002c-overview-57"></a>
NetCDF-4 added support for hierarchical groups within netCDF
datasets.

   <p>Groups are identified with a ncid, which identifies both the open
file, and the group within that file. When a file is opened with
NF90_OPEN or NF90_CREATE, the ncid for the root group of that file is
provided. Using that as a starting point, users can add new groups, or
list and navigate existing groups.

   <p>All netCDF calls take a ncid which determines where the call will
take its action. For example, the NF90_DEF_VAR function takes a ncid as
its first parameter. It will create a variable in whichever group
its ncid refers to. Use the root ncid provided by NF90_CREATE or
NF90_OPEN to create a variable in the root group. Or use NF90_DEF_GRP to
create a group and use its ncid to define a variable in the new
group.

   <p>Variable are only visible in the group in which they are defined. The
same applies to attributes. &ldquo;Global&rdquo; attributes are defined in
whichever group is refered to by the ncid.

   <p>Dimensions are visible in their groups, and all child groups.

   <p>Group operations are only permitted on netCDF-4 files - that is, files
created with the HDF5 flag in nf90_create. (see <a href="#NF90_005fCREATE">NF90_CREATE</a>). Groups
are not compatible with the netCDF classic data model, so files
created with the NC_CLASSIC_MODEL file cannot contain groups (except
the root group).

<ul class="menu">
<li><a accesskey="1" href="#NF90_005fINQ_005fNCID">NF90_INQ_NCID</a>
<li><a accesskey="2" href="#NF90_005fINQ_005fGRPS">NF90_INQ_GRPS</a>
<li><a accesskey="3" href="#NF90_005fINQ_005fVARIDS">NF90_INQ_VARIDS</a>
<li><a accesskey="4" href="#NF90_005fINQ_005fDIMIDS">NF90_INQ_DIMIDS</a>
<li><a accesskey="5" href="#NF90_005fINQ_005fGRPNAME_005fLEN">NF90_INQ_GRPNAME_LEN</a>
<li><a accesskey="6" href="#NF90_005fINQ_005fGRPNAME">NF90_INQ_GRPNAME</a>
<li><a accesskey="7" href="#NF90_005fINQ_005fGRPNAME_005fFULL">NF90_INQ_GRPNAME_FULL</a>
<li><a accesskey="8" href="#NF90_005fINQ_005fGRP_005fPARENT">NF90_INQ_GRP_PARENT</a>
<li><a accesskey="9" href="#NF90_005fDEF_005fGRP">NF90_DEF_GRP</a>
</ul>

<div class="node">
<p><hr>
<a name="NF90_005fINQ_005fNCID"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQ_005fGRPS">NF90_INQ_GRPS</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Groups">Groups</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Groups">Groups</a>
<br>
</div>

<h3 class="section">3.1 Find a Group ID: NF90_INQ_NCID</h3>

<p><a name="index-NF90_005fINQ_005fNCID-58"></a>
Given an ncid and group name (NULL or "" gets root group), return
ncid of the named group.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_inq_ncid(ncid, name, grp_ncid)
         integer, intent(in) :: ncid
         character (len = *), intent(in) :: name
         integer, intent(out) :: grp_ncid
         integer :: nf90_inq_ncid
</pre>
     <dl>
<dt><code>NCID</code><dd>The group id for this operation.

     <br><dt><code>NAME</code><dd>A character array that holds the name of the desired group. Must be
less then NF90_MAX_NAME.

     <br><dt><code>GRPID</code><dd>The ID of the group will go here.

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADID</code><dd>Bad group id.

     <br><dt><code>NF90_ENOTNC4</code><dd>Attempting a netCDF-4 operation on a netCDF-3 file. NetCDF-4
operations can only be performed on files defined with a create mode
which includes flag HDF5. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_ESTRICTNC3</code><dd>This file was created with the strict netcdf-3 flag, therefore
netcdf-4 operations are not allowed. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_EHDFERR</code><dd>An error was reported by the HDF5 layer.

</dl>

<h3 class="heading">Example</h3>

<p>This example is from nf90_test/ftst_groups.F.

<pre class="example"></pre>
   <div class="node">
<p><hr>
<a name="NF90_005fINQ_005fGRPS"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQ_005fVARIDS">NF90_INQ_VARIDS</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQ_005fNCID">NF90_INQ_NCID</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Groups">Groups</a>
<br>
</div>

<h3 class="section">3.2 Get a List of Groups in a Group: NF90_INQ_GRPS</h3>

<p><a name="index-NF90_005fINQ_005fGRPS-59"></a>
Given a location id, return the number of groups it contains, and an
array of their ncids.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_inq_grps(ncid, numgrps, ncids)
         integer, intent(in) :: ncid
         integer, intent(out) :: numgrps
         integer, intent(out) :: ncids
         integer :: nf90_inq_grps
</pre>
     <dl>
<dt><code>NCID</code><dd>The group id for this operation.

     <br><dt><code>NUMGRPS</code><dd>An integer which will get number of groups in this group.

     <br><dt><code>NCIDS</code><dd>An array of ints which will receive the IDs of all the groups in this
group.

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADID</code><dd>Bad group id.

     <br><dt><code>NF90_ENOTNC4</code><dd>Attempting a netCDF-4 operation on a netCDF-3 file. NetCDF-4
operations can only be performed on files defined with a create mode
which includes flag HDF5. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_ESTRICTNC3</code><dd>This file was created with the strict netcdf-3 flag, therefore
netcdf-4 operations are not allowed. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_EHDFERR</code><dd>An error was reported by the HDF5 layer.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fINQ_005fVARIDS"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQ_005fDIMIDS">NF90_INQ_DIMIDS</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQ_005fGRPS">NF90_INQ_GRPS</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Groups">Groups</a>
<br>
</div>

<h3 class="section">3.3 Find all the Variables in a Group: NF90_INQ_VARIDS</h3>

<p><a name="index-NF90_005fINQ_005fVARIDS-60"></a>
Find all varids for a location.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_inq_varids(ncid, nvars, varids)
         integer, intent(in) :: ncid
         integer, intent(out) :: nvars
         integer, intent(out) :: varids
         integer :: nf90_inq_varids
</pre>
     <dl>
<dt><code>NCID</code><dd>The group id for this operation.

     <br><dt><code>VARIDS</code><dd>An already allocated array to store the list of varids. Use
nf90_inq_nvars to find out how many variables there
are. (see <a href="#NF90_005fINQUIRE_005fVARIABLE">NF90_INQUIRE_VARIABLE</a>).

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADID</code><dd>Bad group id.

     <br><dt><code>NF90_ENOTNC4</code><dd>Attempting a netCDF-4 operation on a netCDF-3 file. NetCDF-4
operations can only be performed on files defined with a create mode
which includes flag HDF5. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_ESTRICTNC3</code><dd>This file was created with the strict netcdf-3 flag, therefore
netcdf-4 operations are not allowed. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_EHDFERR</code><dd>An error was reported by the HDF5 layer.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fINQ_005fDIMIDS"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQ_005fGRPNAME_005fLEN">NF90_INQ_GRPNAME_LEN</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQ_005fVARIDS">NF90_INQ_VARIDS</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Groups">Groups</a>
<br>
</div>

<h3 class="section">3.4 Find all Dimensions Visible in a Group: NF90_INQ_DIMIDS</h3>

<p><a name="index-NF90_005fINQ_005fDIMIDS-61"></a>
Find all dimids for a location. This finds all dimensions in a group,
or any of its parents.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_inq_dimids(ncid, ndims, dimids, include_parents)
         integer, intent(in) :: ncid
         integer, intent(out) :: ndims
         integer, intent(out) :: dimids
         integer, intent(out) :: include_parents
         integer :: nf90_inq_dimids
</pre>
     <dl>
<dt><code>NCID</code><dd>The group id for this operation.

     <br><dt><code>DIMIDS</code><dd>An array of ints when the dimids of the visible dimensions will be
stashed. Use nf90_inq_ndims to find out how many dims are visible from
this group. (see <a href="#NF90_005fINQUIRE_005fVARIABLE">NF90_INQUIRE_VARIABLE</a>).

     <br><dt><code>INCLUDE_PARENTS</code><dd>If zero, only the group specified by NCID will be searched for
dimensions. Otherwise parent groups will be searched too.

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADID</code><dd>Bad group id.

     <br><dt><code>NF90_ENOTNC4</code><dd>Attempting a netCDF-4 operation on a netCDF-3 file. NetCDF-4
operations can only be performed on files defined with a create mode
which includes flag HDF5. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_ESTRICTNC3</code><dd>This file was created with the strict netcdf-3 flag, therefore
netcdf-4 operations are not allowed. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_EHDFERR</code><dd>An error was reported by the HDF5 layer.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fINQ_005fGRPNAME_005fLEN"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQ_005fGRPNAME">NF90_INQ_GRPNAME</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQ_005fDIMIDS">NF90_INQ_DIMIDS</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Groups">Groups</a>
<br>
</div>

<h3 class="section">3.5 Find the Length of a Group's Full Name: NF90_INQ_GRPNAME_LEN</h3>

<p><a name="index-NF90_005fINQ_005fGRPNAME_005fLEN-62"></a>
Given ncid, find length of the full name. (Root group is named "/",
with length 1.)

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_inq_grpname_len(ncid, len)
         integer, intent(in) :: ncid
         integer, intent(out) :: len
         integer :: nf90_inq_grpname_len
     
         nf90_inq_grpname_len = nf_inq_grpname_len(ncid, len)
       end function nf90_inq_grpname_len
</pre>
     <dl>
<dt><code>NCID</code><dd>The group id for this operation.

     <br><dt><code>LEN</code><dd>An integer where the length will be placed.

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADID</code><dd>Bad group id.

     <br><dt><code>NF90_ENOTNC4</code><dd>Attempting a netCDF-4 operation on a netCDF-3 file. NetCDF-4
operations can only be performed on files defined with a create mode
which includes flag HDF5. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_ESTRICTNC3</code><dd>This file was created with the strict netcdf-3 flag, therefore
netcdf-4 operations are not allowed. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_EHDFERR</code><dd>An error was reported by the HDF5 layer.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fINQ_005fGRPNAME"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQ_005fGRPNAME_005fFULL">NF90_INQ_GRPNAME_FULL</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQ_005fGRPNAME_005fLEN">NF90_INQ_GRPNAME_LEN</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Groups">Groups</a>
<br>
</div>

<h3 class="section">3.6 Find a Group's Name: NF90_INQ_GRPNAME</h3>

<p><a name="index-NF90_005fINQ_005fGRPNAME-63"></a>
Given ncid, find relative name of group. (Root group is named "/").

   <p>The name provided by this function is relative to the parent
group. For a full path name for the group is, with all parent groups
included, separated with a forward slash (as in Unix directory names) See <a href="#NF90_005fINQ_005fGRPNAME_005fFULL">NF90_INQ_GRPNAME_FULL</a>.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_inq_grpname(ncid, name)
         integer, intent(in) :: ncid
         character (len = *), intent(out) :: name
         integer :: nf90_inq_grpname
</pre>
     <dl>
<dt><code>NCID</code><dd>The group id for this operation.

     <br><dt><code>NAME</code><dd>The name of the
group will be copied to this character array. The name will be less
than NF90_MAX_NAME in length. 
<br><dt><dd>
</dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADID</code><dd>Bad group id.

     <br><dt><code>NF90_ENOTNC4</code><dd>Attempting a netCDF-4 operation on a netCDF-3 file. NetCDF-4
operations can only be performed on files defined with a create mode
which includes flag HDF5. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_ESTRICTNC3</code><dd>This file was created with the strict netcdf-3 flag, therefore
netcdf-4 operations are not allowed. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_EHDFERR</code><dd>An error was reported by the HDF5 layer.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fINQ_005fGRPNAME_005fFULL"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQ_005fGRP_005fPARENT">NF90_INQ_GRP_PARENT</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQ_005fGRPNAME">NF90_INQ_GRPNAME</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Groups">Groups</a>
<br>
</div>

<h3 class="section">3.7 Find a Group's Full Name: NF90_INQ_GRPNAME_FULL</h3>

<p><a name="index-NF90_005fINQ_005fGRPNAME_005fFULL-64"></a>
Given ncid, find complete name of group. (Root group is named "/").

   <p>The name provided by this function is a full path name for the group
is, with all parent groups included, separated with a forward slash
(as in Unix directory names). For a name relative to the parent group
See <a href="#NF90_005fINQ_005fGRPNAME">NF90_INQ_GRPNAME</a>.

   <p>To find the length of the full name See <a href="#NF90_005fINQ_005fGRPNAME_005fLEN">NF90_INQ_GRPNAME_LEN</a>.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_inq_grpname_full(ncid, len, name)
         integer, intent(in) :: ncid
         integer, intent(out) :: len
         character (len = *), intent(out) :: name
         integer :: nf90_inq_grpname_full
</pre>
     <dl>
<dt><code>NCID</code><dd>The group id for this operation.

     <br><dt><code>LEN</code><dd>The length of the full group name will go here.

     <br><dt><code>NAME</code><dd>The name of the group will be copied to this character array.

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADID</code><dd>Bad group id.

     <br><dt><code>NF90_ENOTNC4</code><dd>Attempting a netCDF-4 operation on a netCDF-3 file. NetCDF-4
operations can only be performed on files defined with a create mode
which includes flag HDF5. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_ESTRICTNC3</code><dd>This file was created with the strict netcdf-3 flag, therefore
netcdf-4 operations are not allowed. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_EHDFERR</code><dd>An error was reported by the HDF5 layer.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fINQ_005fGRP_005fPARENT"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fDEF_005fGRP">NF90_DEF_GRP</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQ_005fGRPNAME_005fFULL">NF90_INQ_GRPNAME_FULL</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Groups">Groups</a>
<br>
</div>

<h3 class="section">3.8 Find a Group's Parent: NF90_INQ_GRP_PARENT</h3>

<p><a name="index-NF90_005fINQ_005fGRP_005fPARENT-65"></a>
Given ncid, find the ncid of the parent group.

   <p>When used with the root group, this function returns the NF90_ENOGRP
error (since the root group has no parent.)

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_inq_grp_parent(ncid, parent_ncid)
         integer, intent(in) :: ncid
         integer, intent(out) :: parent_ncid
         integer :: nf90_inq_grp_parent
</pre>
     <dl>
<dt><code>NCID</code><dd>The group id.

     <br><dt><code>PARENT_NCID</code><dd>The ncid of the parent group will be copied here.

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADID</code><dd>Bad group id.

     <br><dt><code>NF90_ENOGRP</code><dd>No parent group found (i.e. this is the root group).

     <br><dt><code>NF90_ENOTNC4</code><dd>Attempting a netCDF-4 operation on a netCDF-3 file. NetCDF-4
operations can only be performed on files defined with a create mode
which includes flag HDF5. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_ESTRICTNC3</code><dd>This file was created with the strict netcdf-3 flag, therefore
netcdf-4 operations are not allowed. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_EHDFERR</code><dd>An error was reported by the HDF5 layer.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fDEF_005fGRP"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQ_005fGRP_005fPARENT">NF90_INQ_GRP_PARENT</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Groups">Groups</a>
<br>
</div>

<h3 class="section">3.9 Create a New Group: NF90_DEF_GRP</h3>

<p><a name="index-NF90_005fDEF_005fGRP-66"></a>
Create a group. Its location id is returned in new_ncid.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_def_grp(parent_ncid, name, new_ncid)
         integer, intent(in) :: parent_ncid
         character (len = *), intent(in) :: name
         integer, intent(out) :: new_ncid
         integer :: nf90_def_grp
</pre>
     <dl>
<dt><code>PARENT_NCID</code><dd>The group id of the parent group.

     <br><dt><code>NAME</code><dd>The name of the new group.

     <br><dt><code>NEW_NCID</code><dd>The ncid of the new group will be placed there.

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADID</code><dd>Bad group id.

     <br><dt><code>NF90_ENAMEINUSE</code><dd>That name is in use. Group names must be unique within a group.

     <br><dt><code>NF90_EMAXNAME</code><dd>Name exceed max length NF90_MAX_NAME.

     <br><dt><code>NF90_EBADNAME</code><dd>Name contains illegal characters.

     <br><dt><code>NF90_ENOTNC4</code><dd>Attempting a netCDF-4 operation on a netCDF-3 file. NetCDF-4
operations can only be performed on files defined with a create mode
which includes flag HDF5. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_ESTRICTNC3</code><dd>This file was created with the strict netcdf-3 flag, therefore
netcdf-4 operations are not allowed. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_EHDFERR</code><dd>An error was reported by the HDF5 layer.

     <br><dt><code>NF90_EPERM</code><dd>Attempt to write to a read-only file.

     <br><dt><code>NF90_ENOTINDEFINE</code><dd>Not in define mode.

</dl>

<h3 class="heading">Example</h3>

<pre class="example">     C     Create the netCDF file.
           retval = nf90_create(file_name, NF90_NETCDF4, ncid)
           if (retval .ne. nf90_noerr) call handle_err(retval)
     
     C     Create a group and a subgroup.
           retval = nf90_def_grp(ncid, group_name, grpid)
           if (retval .ne. nf90_noerr) call handle_err(retval)
           retval = nf90_def_grp(grpid, sub_group_name, sub_grpid)
           if (retval .ne. nf90_noerr) call handle_err(retval)
</pre>
<div class="node">
<p><hr>
<a name="Dimensions"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#User-Defined-Data-Types">User Defined Data Types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Groups">Groups</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="chapter">4 Dimensions</h2>

<ul class="menu">
<li><a accesskey="1" href="#Dimensions-Introduction">Dimensions Introduction</a>
<li><a accesskey="2" href="#NF90_005fDEF_005fDIM">NF90_DEF_DIM</a>
<li><a accesskey="3" href="#NF90_005fINQ_005fDIMID">NF90_INQ_DIMID</a>
<li><a accesskey="4" href="#NF90_005fINQUIRE_005fDIMENSION">NF90_INQUIRE_DIMENSION</a>
<li><a accesskey="5" href="#NF90_005fRENAME_005fDIM">NF90_RENAME_DIM</a>
</ul>

<div class="node">
<p><hr>
<a name="Dimensions-Introduction"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fDEF_005fDIM">NF90_DEF_DIM</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Dimensions">Dimensions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Dimensions">Dimensions</a>
<br>
</div>

<h3 class="section">4.1 Dimensions Introduction</h3>

<p>Dimensions for a netCDF dataset are defined when it is created, while
the netCDF dataset is in define mode. Additional dimensions may be
added later by reentering define mode. A netCDF dimension has a name
and a length. At most one dimension in a netCDF dataset can have the
unlimited length, which means variables using this dimension can grow
along this dimension.

   <p>There is a suggested limit (512) to the number of dimensions that can
be defined in a single netCDF dataset. The limit is the value of the
constant NF90_MAX_DIMS. The purpose of the limit is to make writing
generic applications simpler. They need only provide an array of
NF90_MAX_DIMS dimensions to handle any netCDF dataset. The
implementation of the netCDF library does not enforce this advisory
maximum, so it is possible to use more dimensions, if necessary, but
netCDF utilities that assume the advisory maximums may not be able to
handle the resulting netCDF datasets.

   <p>Ordinarily, the name and length of a dimension are fixed when the
dimension is first defined. The name may be changed later, but the
length of a dimension (other than the unlimited dimension) cannot be
changed without copying all the data to a new netCDF dataset with a
redefined dimension length.

   <p>A netCDF dimension in an open netCDF dataset is referred to by a small
integer called a dimension ID. In the Fortran 90 interface, dimension
IDs are 1, 2, 3, ..., in the order in which the dimensions were
defined.

   <p>Operations supported on dimensions are:
     <ul>
<li>Create a dimension, given its name and length.

     <li>Get a dimension ID from its name.

     <li>Get a dimension's name and length from its ID.

     <li>Rename a dimension. 
</ul>

<div class="node">
<p><hr>
<a name="NF90_005fDEF_005fDIM"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQ_005fDIMID">NF90_INQ_DIMID</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Dimensions-Introduction">Dimensions Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Dimensions">Dimensions</a>
<br>
</div>

<h3 class="section">4.2 NF90_DEF_DIM</h3>

<p><a name="index-NF90_005fDEF_005fDIM-67"></a><a name="index-NF90_005fDEF_005fDIM_002c-example-68"></a>
The function NF90_DEF_DIM adds a new dimension to an open netCDF dataset
in define mode. It returns (as an argument) a dimension ID, given the
netCDF ID, the dimension name, and the dimension length. At most one
unlimited length dimension, called the record dimension, may be
defined for each netCDF dataset.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_def_dim(ncid, name, len, dimid)
        integer,             intent( in) :: ncid
        character (len = *), intent( in) :: name
        integer,             intent( in) :: len
        integer,             intent(out) :: dimid
        integer                          :: nf90_def_dim
</pre>
     <dl>
<dt><code>ncid</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>name</code><dd>Dimension name. Must begin with an alphabetic character, followed by
zero or more alphanumeric characters including the underscore
('_'). Case is significant.

     <br><dt><code>len</code><dd>Length of dimension; that is, number of values for this dimension as
an index to variables that use it. This should be either a positive
integer or the predefined constant NF90_UNLIMITED.

     <br><dt><code>dimid</code><dd>Returned dimension ID. 
</dl>

<h3 class="heading">Errors</h3>

<p>NF90_DEF_DIM returns the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
     <ul>
<li>The netCDF dataset is not in definition mode.

     <li>The specified dimension name is the name of another existing
dimension.

     <li>The specified length is not greater than zero.

     <li>The specified length is unlimited, but there is already an unlimited
length dimension defined for this netCDF dataset.

     <li>The specified netCDF ID does not refer to an open netCDF dataset.

   </ul>

<h3 class="heading">Example</h3>

<p>Here is an example using NF90_DEF_DIM to create a dimension named lat of
length 18 and a unlimited dimension named rec in a new netCDF dataset
named foo.nc:

<pre class="example">      use netcdf
      implicit none
      integer :: ncid, status, LatDimID, RecordDimID
      ...
      status = nf90_create("foo.nc", nf90_noclobber, ncid)
      if (status /= nf90_noerr) call handle_err(status)
      ...
      status = nf90_def_dim(ncid, "Lat", 18, LatDimID)
      if (status /= nf90_noerr) call handle_err(status)
      status = nf90_def_dim(ncid, "Record", nf90_unlimited, RecordDimID)
      if (status /= nf90_noerr) call handle_err(status)
</pre>
   <div class="node">
<p><hr>
<a name="NF90_005fINQ_005fDIMID"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQUIRE_005fDIMENSION">NF90_INQUIRE_DIMENSION</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fDEF_005fDIM">NF90_DEF_DIM</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Dimensions">Dimensions</a>
<br>
</div>

<h3 class="section">4.3 NF90_INQ_DIMID</h3>

<p><a name="index-NF90_005fINQ_005fDIMID-69"></a><a name="index-NF90_005fINQ_005fDIMID-_002c-example-70"></a>
The function NF90_INQ_DIMID returns (as an argument) the ID of a netCDF
dimension, given the name of the dimension. If ndims is the number of
dimensions defined for a netCDF dataset, each dimension has an ID
between 1 and ndims.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_inq_dimid(ncid, name, dimid)
        integer,             intent( in) :: ncid
        character (len = *), intent( in) :: name
        integer,             intent(out) :: dimid
        integer                          :: nf90_inq_dimid
</pre>
     <dl>
<dt><code>ncid</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>name</code><dd>Dimension name, a character string beginning with a letter and
followed by any sequence of letters, digits, or underscore ('_')
characters. Case is significant in dimension names.

     <br><dt><code>dimid</code><dd>Returned dimension ID. 
</dl>

<h3 class="heading">Errors</h3>

<p>NF90_INQ_DIMID returns the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:

     <ul>
<li>The name that was specified is not the name of a dimension in the
netCDF dataset.

     <li>The specified netCDF ID does not refer to an open netCDF dataset.

   </ul>

<h3 class="heading">Example</h3>

<p>Here is an example using NF90_INQ_DIMID to determine the dimension ID of
a dimension named lat, assumed to have been defined previously in an
existing netCDF dataset named foo.nc:

<pre class="example">      use netcdf
      implicit none
      integer :: ncid, status, LatDimID
      ...
      status = nf90_open("foo.nc", nf90_nowrite, ncid)
      if (status /= nf90_noerr) call handle_err(status)
      ...
      status = nf90_inq_dimid(ncid, "Lat", LatDimID)
      if (status /= nf90_noerr) call handle_err(status)
</pre>
   <div class="node">
<p><hr>
<a name="NF90_005fINQUIRE_005fDIMENSION"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fRENAME_005fDIM">NF90_RENAME_DIM</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQ_005fDIMID">NF90_INQ_DIMID</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Dimensions">Dimensions</a>
<br>
</div>

<h3 class="section">4.4 NF90_INQUIRE_DIMENSION</h3>

<p><a name="index-NF90_005fINQUIRE_005fDIMENSION-71"></a><a name="index-NF90_005fINQUIRE_005fDIMENSION-_002c-example-72"></a>
This function information about a netCDF dimension. Information about
a dimension includes its name and its length. The length for the
unlimited dimension, if any, is the number of records written so far.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_inquire_dimension(ncid, dimid, name, len)
        integer,                       intent( in) :: ncid, dimid
        character (len = *), optional, intent(out) :: name
        integer,             optional, intent(out) :: len
        integer                                    :: nf90_inquire_dimension
</pre>
     <dl>
<dt><code>ncid</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>dimid</code><dd>Dimension ID, from a previous call to NF90_INQ_DIMID or NF90_DEF_DIM.

     <br><dt><code>name</code><dd>Returned dimension name. The caller must allocate space for the
returned name. The maximum possible length, in characters, of a
dimension name is given by the predefined constant NF90_MAX_NAME.

     <br><dt><code>len</code><dd>Returned length of dimension. For the unlimited dimension, this is the
current maximum value used for writing any variables with this
dimension, that is the maximum record number. 
</dl>

<h3 class="heading">Errors</h3>

<p>These functions return the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:

     <ul>
<li>The dimension ID is invalid for the specified netCDF dataset.

     <li>The specified netCDF ID does not refer to an open netCDF dataset.

   </ul>

<h3 class="heading">Example</h3>

<p>Here is an example using NF90_INQ_DIM to determine the length of a
dimension named lat, and the name and current maximum length of the
unlimited dimension for an existing netCDF dataset named foo.nc:

<pre class="example">      use netcdf
      implicit none
      integer :: ncid, status, LatDimID, RecordDimID
      integer :: nLats, nRecords
      character(len = nf90_max_name) :: RecordDimName
      ...
      status = nf90_open("foo.nc", nf90_nowrite, ncid)
      if (status /= nf90_noerr) call handle_err(status)
      ! Get ID of unlimited dimension
      status = nf90_inquire(ncid, unlimitedDimId = RecordDimID)
      if (status /= nf90_noerr) call handle_err(status)
      ...
      status = nf90_inq_dimid(ncid, "Lat", LatDimID)
      if (status /= nf90_noerr) call handle_err(status)
      ! How many values of "lat" are there?
      status = nf90_inquire_dimension(ncid, LatDimID, len = nLats)
      if (status /= nf90_noerr) call handle_err(status)
      ! What is the name of the unlimited dimension, how many records are there?
      status = nf90_inquire_dimension(ncid, RecordDimID, &amp;
                                      name = RecordDimName, len = Records)
      if (status /= nf90_noerr) call handle_err(status)
</pre>
   <div class="node">
<p><hr>
<a name="NF90_005fRENAME_005fDIM"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQUIRE_005fDIMENSION">NF90_INQUIRE_DIMENSION</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Dimensions">Dimensions</a>
<br>
</div>

<h3 class="section">4.5 NF90_RENAME_DIM</h3>

<p><a name="index-NF90_005fRENAME_005fDIM-73"></a><a name="index-NF90_005fRENAME_005fDIM-_002c-example-74"></a>
The function NF90_RENAME_DIM renames an existing dimension in a netCDF
dataset open for writing. If the new name is longer than the old name,
the netCDF dataset must be in define mode. You cannot rename a
dimension to have the same name as another dimension.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_rename_dim(ncid, dimid, name)
        integer,             intent( in) :: ncid
        character (len = *), intent( in) :: name
        integer,             intent( in) :: dimid
        integer                          :: nf90_rename_dim
</pre>
     <dl>
<dt><code>ncid</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>dimid</code><dd>Dimension ID, from a previous call to NF90_INQ_DIMID or NF90_DEF_DIM.

     <br><dt><code>name</code><dd>New dimension name.

   </dl>

<h3 class="heading">Errors</h3>

<p>NF90_RENAME_DIM returns the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:

     <ul>
<li>The new name is the name of another dimension.

     <li>The dimension ID is invalid for the specified netCDF dataset.

     <li>The specified netCDF ID does not refer to an open netCDF dataset.

     <li>The new name is longer than the old name and the netCDF dataset is not
in define mode. 
</ul>

<h3 class="heading">Example</h3>

<p>Here is an example using NF90_RENAME_DIM to rename the dimension lat to
latitude in an existing netCDF dataset named foo.nc:

<pre class="example">      use netcdf
      implicit none
      integer :: ncid, status, LatDimID
      ...
      status = nf90_open("foo.nc", nf90_write, ncid)
      if (status /= nf90_noerr) call handle_err(status)
      ...
      ! Put in define mode so we can rename the dimension
      status = nf90_redef(ncid)
      if (status /= nf90_noerr) call handle_err(status)
      ! Get the dimension ID for "Lat"...
      status = nf90_inq_dimid(ncid, "Lat", LatDimID)
      if (status /= nf90_noerr) call handle_err(status)
      ! ... and change the name to "Latitude".
      status = nf90_rename_dim(ncid, LatDimID, "Latitude")
      if (status /= nf90_noerr) call handle_err(status)
      ! Leave define mode
      status = nf90_enddef(ncid)
      if (status /= nf90_noerr) call handle_err(status)
</pre>
   <div class="node">
<p><hr>
<a name="User-Defined-Data-Types"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Variables">Variables</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Dimensions">Dimensions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="chapter">5 User Defined Data Types</h2>

<p><a name="index-variable-length-array-type_002c-overview-75"></a><a name="index-user-defined-types-76"></a>

<ul class="menu">
<li><a accesskey="1" href="#User-Defined-Types">User Defined Types</a>
<li><a accesskey="2" href="#NF90_005fINQ_005fTYPEIDS">NF90_INQ_TYPEIDS</a>
<li><a accesskey="3" href="#NF90_005fINQ_005fTYPE">NF90_INQ_TYPE</a>
<li><a accesskey="4" href="#NF90_005fINQ_005fUSER_005fTYPE">NF90_INQ_USER_TYPE</a>
<li><a accesskey="5" href="#Compound-Types">Compound Types</a>
<li><a accesskey="6" href="#Variable-Length-Array">Variable Length Array</a>
<li><a accesskey="7" href="#Opaque-Type">Opaque Type</a>
<li><a accesskey="8" href="#Enum-Type">Enum Type</a>
</ul>

<div class="node">
<p><hr>
<a name="User-Defined-Types"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQ_005fTYPEIDS">NF90_INQ_TYPEIDS</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#User-Defined-Data-Types">User Defined Data Types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Defined-Data-Types">User Defined Data Types</a>
<br>
</div>

<h3 class="section">5.1 User Defined Types Introduction</h3>

<p><a name="index-user-defined-types_002c-overview-77"></a>
NetCDF-4 has added support for four different user defined data types.

     <dl>
<dt><code>compound type</code><dd>Like a C struct, a compound type is a collection of types, including
other user defined types, in one package.

     <br><dt><code>variable length array type</code><dd>The variable length array may be used to store ragged arrays.

     <br><dt><code>opaque type</code><dd>This type has only a size per element, and no other type information.

     <br><dt><code>enum type</code><dd>Like an enumeration in C, this type lets you assign text values to
integer values, and store the integer values.

   </dl>

   <p>Users may construct user defined type with the various nf90_def_*
functions described in this section. They may learn about user defined
types by using the nf90_inq_ functions defined in this section.

<div class="node">
<p><hr>
<a name="NF90_005fINQ_005fTYPEIDS"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQ_005fTYPE">NF90_INQ_TYPE</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#User-Defined-Types">User Defined Types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Defined-Data-Types">User Defined Data Types</a>
<br>
</div>

<h3 class="section">5.2 Learn the IDs of All Types in Group: NF90_INQ_TYPEIDS</h3>

<p><a name="index-NF90_005fINQ_005fTYPEIDS-78"></a>
Learn the number of types defined in a group, and their IDs.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_inq_typeids(ncid, ntypes, typeids)
         integer, intent(in) :: ncid
         integer, intent(out) :: ntypes
         integer, intent(out) :: typeids
         integer :: nf90_inq_typeids
</pre>
     <dl>
<dt><code>NCID</code><dd>The group id.

     <br><dt><code>NTYPES</code><dd>A pointer to int which will get the number of types defined in the
group. If NULL, ignored.

     <br><dt><code>TYPEIDS</code><dd>A pointer to an int array which will get the typeids. If NULL,
ignored.

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_BADID</code><dd>Bad ncid.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fINQ_005fTYPE"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQ_005fUSER_005fTYPE">NF90_INQ_USER_TYPE</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQ_005fTYPEIDS">NF90_INQ_TYPEIDS</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Defined-Data-Types">User Defined Data Types</a>
<br>
</div>

<h3 class="section">5.3 Learn About an User Defined Type: NF90_INQ_TYPE</h3>

<p><a name="index-NF90_005fINQ_005fTYPE-79"></a>
Given an ncid and a typeid, get the information about a type. This
function will work on any type, including atomic and any user defined
type, whether compound, opaque, enumeration, or variable length array.

   <p>For even more information about a user defined type <a href="#NF90_005fINQ_005fUSER_005fTYPE">NF90_INQ_USER_TYPE</a>.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_inq_type(ncid, xtype, name, size, nfields)
         integer, intent(in) :: ncid
         integer, intent(in) :: xtype
         character (len = *), intent(out) :: name
         integer, intent(out) :: size
         integer, intent(out) :: nfields
         integer :: nf90_inq_type
</pre>
     <dl>
<dt><code>NCID</code><dd>The ncid for the group containing the type (ignored for atomic types).

     <br><dt><code>XTYPE</code><dd>The typeid for this type, as returned by NF90_DEF_COMPOUND,
NF90_DEF_OPAQUE, NF90_DEF_ENUM, NF90_DEF_VLEN, or NF90_INQ_VAR, or as found in
netcdf.inc in the list of atomic types (NF90_CHAR, NF90_INT, etc.).

     <br><dt><code>NAME</code><dd>The name of the user defined type will be copied here. It will be
NF90_MAX_NAME bytes or less. For atomic types, the type name from CDL
will be given.

     <br><dt><code>SIZEP</code><dd>The size of the type (in bytes) will be copied here. VLEN type size is
the size of one element of the VLEN. String size is returned as zero,
since it varies from string to string.

   </dl>

<h3 class="heading">Return Codes</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADTYPEID</code><dd>Bad typeid.

     <br><dt><code>NF90_ENOTNC4</code><dd>Seeking a user-defined type in a netCDF-3 file.

     <br><dt><code>NF90_ESTRICTNC3</code><dd>Seeking a user-defined type in a netCDF-4 file for which classic model
has been turned on.

     <br><dt><code>NF90_EBADGRPID</code><dd>Bad group ID in ncid.

     <br><dt><code>NF90_EBADID</code><dd>Type ID not found.

     <br><dt><code>NF90_EHDFERR</code><dd>An error was reported by the HDF5 layer.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fINQ_005fUSER_005fTYPE"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Compound-Types">Compound Types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQ_005fTYPE">NF90_INQ_TYPE</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Defined-Data-Types">User Defined Data Types</a>
<br>
</div>

<h3 class="section">5.4 Learn About an User Defined Type: NF90_INQ_USER_TYPE</h3>

<p><a name="index-NF90_005fINQ_005fUSER_005fTYPE-80"></a>
Given an ncid and a typeid, get the information about a user defined
type. This function will work on any user defined type, whether
compound, opaque, enumeration, or variable length array.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_inq_user_type(ncid, xtype, name, size, base_typeid, nfields, class)
         integer, intent(in) :: ncid
         integer, intent(in) :: xtype
         character (len = *), intent(out) :: name
         integer, intent(out) :: size
         integer, intent(out) :: base_typeid
         integer, intent(out) :: nfields
         integer, intent(out) :: class
         integer :: nf90_inq_user_type
</pre>
     <dl>
<dt><code>NCID</code><dd>The ncid for the group containing the user defined type.

     <br><dt><code>XTYPE</code><dd>The typeid for this type, as returned by NF90_DEF_COMPOUND,
NF90_DEF_OPAQUE, NF90_DEF_ENUM, NF90_DEF_VLEN, or NF90_INQ_VAR.

     <br><dt><code>NAME</code><dd>The name of the user defined type will be copied here. It
will be NF90_MAX_NAME bytes or less.

     <br><dt><code>SIZE</code><dd>The size of the user defined type will be copied here.

     <br><dt><code>BASE_NF90_TYPE</code><dd>The base typeid will be copied here for vlen and enum types.

     <br><dt><code>NFIELDS</code><dd>The number of fields will be copied here for enum and compound types.

     <br><dt><code>CLASS</code><dd>The class of the user defined type, NF90_VLEN, NF90_OPAQUE, NF90_ENUM, or
NF90_COMPOUND, will be copied here.

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADTYPEID</code><dd>Bad typeid.

     <br><dt><code>NF90_EBADFIELDID</code><dd>Bad fieldid.

     <br><dt><code>NF90_EHDFERR</code><dd>An error was reported by the HDF5 layer.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<ul class="menu">
<li><a accesskey="1" href="#NF90_005fPUT_005fVLEN_005fELEMENT">NF90_PUT_VLEN_ELEMENT</a>
<li><a accesskey="2" href="#NF90_005fGET_005fVLEN_005fELEMENT">NF90_GET_VLEN_ELEMENT</a>
</ul>

<div class="node">
<p><hr>
<a name="NF90_005fPUT_005fVLEN_005fELEMENT"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fGET_005fVLEN_005fELEMENT">NF90_GET_VLEN_ELEMENT</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQ_005fUSER_005fTYPE">NF90_INQ_USER_TYPE</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#NF90_005fINQ_005fUSER_005fTYPE">NF90_INQ_USER_TYPE</a>
<br>
</div>

<h4 class="subsection">5.4.1 Set a Variable Length Array with NF90_PUT_VLEN_ELEMENT</h4>

<p><a name="index-NF90_005fPUT_005fVLEN_005fELEMENT-81"></a>
Use this to set the element of the (potentially) n-dimensional array
of VLEN. That is, this sets the data in one variable length array.

<h3 class="heading">Usage</h3>

<pre class="example">     INTEGER FUNCTION NF90_PUT_VLEN_ELEMENT(INTEGER NCID, INTEGER XTYPE,
             CHARACTER*(*) VLEN_ELEMENT, INTEGER LEN, DATA)
</pre>
     <dl>
<dt><code>NCID</code><dd>The ncid of the file that contains the VLEN type.

     <br><dt><code>XTYPE</code><dd>The type of the VLEN.

     <br><dt><code>VLEN_ELEMENT</code><dd>The VLEN element to be set.

     <br><dt><code>LEN</code><dd>The number of entries in this array.

     <br><dt><code>DATA</code><dd>The data to be stored. Must match the base type of this VLEN.

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADTYPE</code><dd>Can't find the typeid.

     <br><dt><code>NF90_EBADID</code><dd>ncid invalid.

     <br><dt><code>NF90_EBADGRPID</code><dd>Group ID part of ncid was invalid.

</dl>

<h3 class="heading">Example</h3>

<p>This example is from nf90_test/ftst_vars4.F.

<pre class="example">     C     Set up the vlen with this helper function, since F77 can't deal
     C     with pointers.
           retval = nf90_put_vlen_element(ncid, vlen_typeid, vlen,
          &amp;     vlen_len, data1)
           if (retval .ne. nf90_noerr) call handle_err(retval)
</pre>
   <div class="node">
<p><hr>
<a name="NF90_005fGET_005fVLEN_005fELEMENT"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fPUT_005fVLEN_005fELEMENT">NF90_PUT_VLEN_ELEMENT</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#NF90_005fINQ_005fUSER_005fTYPE">NF90_INQ_USER_TYPE</a>
<br>
</div>

<h4 class="subsection">5.4.2 Set a Variable Length Array with NF90_GET_VLEN_ELEMENT</h4>

<p><a name="index-NF90_005fGET_005fVLEN_005fELEMENT-82"></a>
Use this to set the element of the (potentially) n-dimensional array
of VLEN. That is, this sets the data in one variable length array.

<h3 class="heading">Usage</h3>

<pre class="example">     INTEGER FUNCTION NF90_GET_VLEN_ELEMENT(INTEGER NCID, INTEGER XTYPE,
             CHARACTER*(*) VLEN_ELEMENT, INTEGER LEN, DATA)
</pre>
     <dl>
<dt><code>NCID</code><dd>The ncid of the file that contains the VLEN type.

     <br><dt><code>XTYPE</code><dd>The type of the VLEN.

     <br><dt><code>VLEN_ELEMENT</code><dd>The VLEN element to be set.

     <br><dt><code>LEN</code><dd>This will be set to the number of entries in this array.

     <br><dt><code>DATA</code><dd>The data will be copied here. Sufficient storage must be available or
bad things will happen to you.

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADTYPE</code><dd>Can't find the typeid.

     <br><dt><code>NF90_EBADID</code><dd>ncid invalid.

     <br><dt><code>NF90_EBADGRPID</code><dd>Group ID part of ncid was invalid.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="Compound-Types"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Variable-Length-Array">Variable Length Array</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQ_005fUSER_005fTYPE">NF90_INQ_USER_TYPE</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Defined-Data-Types">User Defined Data Types</a>
<br>
</div>

<h3 class="section">5.5 Compound Types Introduction</h3>

<p><a name="index-compound-types_002c-overview-83"></a>
NetCDF-4 added support for compound types, which allow users to
construct a new type - a combination of other types, like a C struct.

   <p>Compound types are not supported in classic or 64-bit offset format
files.

   <p>To write data in a compound type, first use nf90_def_compound to create the
type, multiple calls to nf90_insert_compound to add to the compound type, and
then write data with the appropriate nf90_put_var1, nf90_put_vara,
nf90_put_vars, or nf90_put_varm call.

   <p>To read data written in a compound type, you must know its
structure. Use the NF90_INQ_COMPOUND functions to learn about the compound
type.

   <p>In Fortran a character buffer must be used for the compound data. The
user must read the data from within that buffer in the same way that
the C compiler which compiled netCDF would store the structure.

   <p>The use of compound types introduces challenges and portability issues
for Fortran users.

<ul class="menu">
<li><a accesskey="1" href="#NF90_005fDEF_005fCOMPOUND">NF90_DEF_COMPOUND</a>
<li><a accesskey="2" href="#NF90_005fINSERT_005fCOMPOUND">NF90_INSERT_COMPOUND</a>
<li><a accesskey="3" href="#NF90_005fINSERT_005fARRAY_005fCOMPOUND">NF90_INSERT_ARRAY_COMPOUND</a>
<li><a accesskey="4" href="#NF90_005fINQ_005fCOMPOUND">NF90_INQ_COMPOUND</a>
<li><a accesskey="5" href="#NF90_005fINQ_005fCOMPOUND_005fFIELD">NF90_INQ_COMPOUND_FIELD</a>
</ul>

<div class="node">
<p><hr>
<a name="NF90_005fDEF_005fCOMPOUND"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINSERT_005fCOMPOUND">NF90_INSERT_COMPOUND</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Compound-Types">Compound Types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Compound-Types">Compound Types</a>
<br>
</div>

<h4 class="subsection">5.5.1 Creating a Compound Type: NF90_DEF_COMPOUND</h4>

<p><a name="index-NF90_005fDEF_005fCOMPOUND-84"></a>
Create a compound type. Provide an ncid, a name, and a total size (in
bytes) of one element of the completed compound type.

   <p>After calling this function, fill out the type with repeated calls to
NF90_INSERT_COMPOUND (see <a href="#NF90_005fINSERT_005fCOMPOUND">NF90_INSERT_COMPOUND</a>). Call
NF90_INSERT_COMPOUND once for each field you wish to insert into the
compound type.

   <p>Note that there does not seem to be a fully portable way to read such
types into structures in Fortran 90 (and there are no structures in
Fortran 77). Dozens of top-notch programmers are swarming over this
problem in a sub-basement of Unidata's giant underground bunker in
Wyoming.

   <p>Fortran users may use character buffers to read and write compound
types. User are invited to try classic Fortran features such as the
equivilence and the common block statment.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_def_compound(ncid, size, name, typeid)
         integer, intent(in) :: ncid
         integer, intent(in) :: size
         character (len = *), intent(in) :: name
         integer, intent(out) :: typeid
         integer :: nf90_def_compound
</pre>
     <dl>
<dt><code>NCID</code><dd>The groupid where this compound type will be created.

     <br><dt><code>SIZE</code><dd>The size, in bytes, of the compound type.

     <br><dt><code>NAME</code><dd>The name of the new compound type.

     <br><dt><code>TYPEIDP</code><dd>The typeid of the new type will be placed here.

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADID</code><dd>Bad group id.

     <br><dt><code>NF90_ENAMEINUSE</code><dd>That name is in use. Compound type names must be unique in the data
file.

     <br><dt><code>NF90_EMAXNAME</code><dd>Name exceeds max length NF90_MAX_NAME.

     <br><dt><code>NF90_EBADNAME</code><dd>Name contains illegal characters.

     <br><dt><code>NF90_ENOTNC4</code><dd>Attempting a netCDF-4 operation on a netCDF-3 file. NetCDF-4
operations can only be performed on files defined with a create mode
which includes flag NF90_NETCDF4. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_ESTRICTNC3</code><dd>This file was created with the strict netcdf-3 flag, therefore
netcdf-4 operations are not allowed. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_EHDFERR</code><dd>An error was reported by the HDF5 layer.

     <br><dt><code>NF90_EPERM</code><dd>Attempt to write to a read-only file.

     <br><dt><code>NF90_ENOTINDEFINE</code><dd>Not in define mode.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fINSERT_005fCOMPOUND"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINSERT_005fARRAY_005fCOMPOUND">NF90_INSERT_ARRAY_COMPOUND</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fDEF_005fCOMPOUND">NF90_DEF_COMPOUND</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Compound-Types">Compound Types</a>
<br>
</div>

<h4 class="subsection">5.5.2 Inserting a Field into a Compound Type: NF90_INSERT_COMPOUND</h4>

<p><a name="index-NF90_005fINSERT_005fCOMPOUND-85"></a>
Insert a named field into a compound type.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_insert_compound(ncid, xtype, name, offset, field_typeid)
         integer, intent(in) :: ncid
         integer, intent(in) :: xtype
         character (len = *), intent(in) :: name
         integer, intent(in) :: offset
         integer, intent(in) :: field_typeid
         integer :: nf90_insert_compound
</pre>
     <dl>
<dt><code>TYPEID</code><dd>The typeid for this compound type, as returned by NF90_DEF_COMPOUND, or
NF90_INQ_VAR.

     <br><dt><code>NAME</code><dd>The name of the new field.

     <br><dt><code>OFFSET</code><dd>Offset in byte from the beginning of the compound type for this
field.

     <br><dt><code>FIELD_TYPEID</code><dd>The type of the field to be inserted.

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADID</code><dd>Bad group id.

     <br><dt><code>NF90_ENAMEINUSE</code><dd>That name is in use. Field names must be unique within a compound type.

     <br><dt><code>NF90_EMAXNAME</code><dd>Name exceed max length NF90_MAX_NAME.

     <br><dt><code>NF90_EBADNAME</code><dd>Name contains illegal characters.

     <br><dt><code>NF90_ENOTNC4</code><dd>Attempting a netCDF-4 operation on a netCDF-3 file. NetCDF-4
operations can only be performed on files defined with a create mode
which includes flag NF90_NETCDF4. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_ESTRICTNC3</code><dd>This file was created with the strict netcdf-3 flag, therefore
netcdf-4 operations are not allowed. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_EHDFERR</code><dd>An error was reported by the HDF5 layer.

     <br><dt><code>NF90_ENOTINDEFINE</code><dd>Not in define mode.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fINSERT_005fARRAY_005fCOMPOUND"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQ_005fCOMPOUND">NF90_INQ_COMPOUND</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINSERT_005fCOMPOUND">NF90_INSERT_COMPOUND</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Compound-Types">Compound Types</a>
<br>
</div>

<h4 class="subsection">5.5.3 Inserting an Array Field into a Compound Type: NF90_INSERT_ARRAY_COMPOUND</h4>

<p><a name="index-NF90_005fINSERT_005fARRAY_005fCOMPOUND-86"></a>
Insert a named array field into a compound type.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_insert_array_compound(ncid, xtype, name, offset, field_typeid, &amp;
            ndims, dim_sizes)
         integer, intent(in) :: ncid
         integer, intent(in) :: xtype
         character (len = *), intent(in) :: name
         integer, intent(in) :: offset
         integer, intent(in) :: field_typeid
         integer, intent(in) :: ndims
         integer, intent(in) :: dim_sizes
         integer :: nf90_insert_array_compound
</pre>
     <dl>
<dt><code>NCID</code><dd>The ID of the file that contains the array type and the compound type.

     <br><dt><code>XTYPE</code><dd>The typeid for this compound type, as returned by nf90_def_compound, or
nf90_inq_var.

     <br><dt><code>NAME</code><dd>The name of the new field.

     <br><dt><code>OFFSET</code><dd>Offset in byte from the beginning of the compound type for this
field.

     <br><dt><code>FIELD_TYPEID</code><dd>The base type of the array to be inserted.

     <br><dt><code>NDIMS</code><dd>The number of dimensions for the array to be inserted.

     <br><dt><code>DIM_SIZES</code><dd>An array containing the sizes of each dimension.

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADID</code><dd>Bad group id.

     <br><dt><code>NF90_ENAMEINUSE</code><dd>That name is in use. Field names must be unique within a compound type.

     <br><dt><code>NF90_EMAXNAME</code><dd>Name exceed max length NF90_MAX_NAME.

     <br><dt><code>NF90_EBADNAME</code><dd>Name contains illegal characters.

     <br><dt><code>NF90_ENOTNC4</code><dd>Attempting a netCDF-4 operation on a netCDF-3 file. NetCDF-4
operations can only be performed on files defined with a create mode
which includes flag NF90_NETCDF4. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_ESTRICTNC3</code><dd>This file was created with the strict netcdf-3 flag, therefore
netcdf-4 operations are not allowed. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_EHDFERR</code><dd>An error was reported by the HDF5 layer.

     <br><dt><code>NF90_ENOTINDEFINE</code><dd>Not in define mode.

     <br><dt><code>NF90_ETYPEDEFINED</code><dd>Attempt to change type that has already been committed. The first time
the file leaves define mode, all defined types are committed, and
can't be changed. If you wish to add an array to a compound type, you
must do so before the compound type is committed.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fINQ_005fCOMPOUND"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQ_005fCOMPOUND_005fFIELD">NF90_INQ_COMPOUND_FIELD</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINSERT_005fARRAY_005fCOMPOUND">NF90_INSERT_ARRAY_COMPOUND</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Compound-Types">Compound Types</a>
<br>
</div>

<h4 class="subsection">5.5.4 Learn About a Compound Type: NF90_INQ_COMPOUND</h4>

<p><a name="index-NF90_005fINQ_005fCOMPOUND-87"></a><a name="index-NF90_005fINQ_005fCOMPOUND_005fNAME-88"></a><a name="index-NF90_005fINQ_005fCOMPOUND_005fSIZE-89"></a><a name="index-NF90_005fINQ_005fCOMPOUND_005fNFIELDS-90"></a>
Get the number of fields, length in bytes, and name of a compound
type.

   <p>In addtion to the NF90_INQ_COMPOUND function, three additional functions
are provided which get only the name, size, and number of fields.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_inq_compound(ncid, xtype, name, size, nfields)
         integer, intent(in) :: ncid
         integer, intent(in) :: xtype
         character (len = *), intent(out) :: name
         integer, intent(out) :: size
         integer, intent(out) :: nfields
         integer :: nf90_inq_compound
     
       function nf90_inq_compound_name(ncid, xtype, name)
         integer, intent(in) :: ncid
         integer, intent(in) :: xtype
         character (len = *), intent(out) :: name
         integer :: nf90_inq_compound_name
     
       function nf90_inq_compound_size(ncid, xtype, size)
         integer, intent(in) :: ncid
         integer, intent(in) :: xtype
         integer, intent(out) :: size
         integer :: nf90_inq_compound_size
     
       function nf90_inq_compound_nfields(ncid, xtype, nfields)
         integer, intent(in) :: ncid
         integer, intent(in) :: xtype
         integer, intent(out) :: nfields
         integer :: nf90_inq_compound_nfields
</pre>
     <dl>
<dt><code>NCID</code><dd>The ID of any group in the file that contains the compound type.

     <br><dt><code>XTYPE</code><dd>The typeid for this compound type, as returned by NF90_DEF_COMPOUND, or
NF90_INQ_VAR.

     <br><dt><code>NAME</code><dd>Character array which will get the name of the compound type. It will
have a maximum length of NF90_MAX_NAME.

     <br><dt><code>SIZEP</code><dd>The size of the compound type in bytes will be put here.

     <br><dt><code>NFIELDSP</code><dd>The number of fields in the compound type will be placed here.

   </dl>

<h3 class="heading">Return Codes</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADID</code><dd>Couldn't find this ncid.

     <br><dt><code>NF90_ENOTNC4</code><dd>Not a netCDF-4/HDF5 file.

     <br><dt><code>NF90_ESTRICTNC3</code><dd>A netCDF-4/HDF5 file, but with CLASSIC_MODEL. No user defined types
are allowed in the classic model.

     <br><dt><code>NF90_EBADTYPE</code><dd>This type not a compound type.

     <br><dt><code>NF90_EBADTYPEID</code><dd>Bad type id.

     <br><dt><code>NF90_EHDFERR</code><dd>An error was reported by the HDF5 layer.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fINQ_005fCOMPOUND_005fFIELD"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQ_005fCOMPOUND">NF90_INQ_COMPOUND</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Compound-Types">Compound Types</a>
<br>
</div>

<h4 class="subsection">5.5.5 Learn About a Field of a Compound Type: NF90_INQ_COMPOUND_FIELD</h4>

<p><a name="index-NF90_005fINQ_005fCOMPOUND_005fFIELD-91"></a><a name="index-NF90_005fINQ_005fCOMPOUND_005fFIELDNAME-92"></a><a name="index-NF90_005fINQ_005fCOMPOUND_005fFIELDINDEX-93"></a><a name="index-NF90_005fINQ_005fCOMPOUND_005fFIELDOFFSET-94"></a><a name="index-NF90_005fINQ_005fCOMPOUND_005fFIELDTYPE-95"></a><a name="index-NF90_005fINQ_005fCOMPOUND_005fFIELDNDIMS-96"></a><a name="index-NF90_005fINQ_005fCMP_005fFIELDDIM_005fSIZES-97"></a>
Get information about one of the fields of a compound type.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_inq_compound_field(ncid, xtype, fieldid, name, offset, &amp;
            field_typeid, ndims, dim_sizes)
         integer, intent(in) :: ncid
         integer, intent(in) :: xtype
         integer, intent(in) :: fieldid
         character (len = *), intent(out) :: name
         integer, intent(out) :: offset
         integer, intent(out) :: field_typeid
         integer, intent(out) :: ndims
         integer, intent(out) :: dim_sizes
         integer :: nf90_inq_compound_field
     
       function nf90_inq_compound_fieldname(ncid, xtype, fieldid, name)
         integer, intent(in) :: ncid
         integer, intent(in) :: xtype
         integer, intent(in) :: fieldid
         character (len = *), intent(out) :: name
         integer :: nf90_inq_compound_fieldname
     
       function nf90_inq_compound_fieldindex(ncid, xtype, name, fieldid)
         integer, intent(in) :: ncid
         integer, intent(in) :: xtype
         character (len = *), intent(in) :: name
         integer, intent(out) :: fieldid
         integer :: nf90_inq_compound_fieldindex
     
       function nf90_inq_compound_fieldoffset(ncid, xtype, fieldid, offset)
         integer, intent(in) :: ncid
         integer, intent(in) :: xtype
         integer, intent(in) :: fieldid
         integer, intent(out) :: offset
         integer :: nf90_inq_compound_fieldoffset
     
       function nf90_inq_compound_fieldtype(ncid, xtype, fieldid, field_typeid)
         integer, intent(in) :: ncid
         integer, intent(in) :: xtype
         integer, intent(in) :: fieldid
         integer, intent(out) :: field_typeid
         integer :: nf90_inq_compound_fieldtype
     
       function nf90_inq_compound_fieldndims(ncid, xtype, fieldid, ndims)
         integer, intent(in) :: ncid
         integer, intent(in) :: xtype
         integer, intent(in) :: fieldid
         integer, intent(out) :: ndims
         integer :: nf90_inq_compound_fieldndims
     
       function nf90_inq_cmp_fielddim_sizes(ncid, xtype, fieldid, dim_sizes)
         integer, intent(in) :: ncid
         integer, intent(in) :: xtype
         integer, intent(in) :: fieldid
         integer, intent(out) :: dim_sizes
         integer :: nf90_inq_cmp_fielddim_sizes
</pre>
     <dl>
<dt><code>NCID</code><dd>The groupid where this compound type exists.

     <br><dt><code>XTYPE</code><dd>The typeid for this compound type, as returned by NF90_DEF_COMPOUND, or
NF90_INQ_VAR.

     <br><dt><code>FIELDID</code><dd>A one-based index number specifying a field in the compound type.

     <br><dt><code>NAME</code><dd>A character array which will get the name of the field. The name will
be NF90_MAX_NAME characters, at most.

     <br><dt><code>OFFSETP</code><dd>An integer which will get the offset of the field.

     <br><dt><code>FIELD_TYPEID</code><dd>An integer which will get the typeid of the field.

     <br><dt><code>NDIMSP</code><dd>An integer which will get the number of dimensions of the field.

     <br><dt><code>DIM_SIZESP</code><dd>An integer array which will get the dimension sizes of the field.

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADTYPEID</code><dd>Bad type id.

     <br><dt><code>NF90_EHDFERR</code><dd>An error was reported by the HDF5 layer.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="Variable-Length-Array"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Opaque-Type">Opaque Type</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Compound-Types">Compound Types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Defined-Data-Types">User Defined Data Types</a>
<br>
</div>

<h3 class="section">5.6 Variable Length Array Introduction</h3>

<p><a name="index-variable-length-arrays-98"></a><a name="index-VLEN-99"></a>
NetCDF-4 added support for a variable length array type. This is not
supported in classic or 64-bit offset files, or in netCDF-4 files
which were created with the NF90_CLASSIC_MODEL flag.

   <p>A variable length array is represented in C as a structure from HDF5,
the nf90_vlen_t structure. It contains a len member, which contains the
length of that array, and a pointer to the array.

   <p>So an array of VLEN in C is an array of nc_vlen_t structures. The only
way to handle this in Fortran is with a character buffer sized
correctly for the platform.

   <p>VLEN arrays are handled differently with respect to allocation of
memory. Generally, when reading data, it is up to the user to malloc
(and subsequently free) the memory needed to hold the data. It is up to
the user to ensure that enough memory is allocated.

   <p>With VLENs, this is impossible. The user cannot know the size of an
array of VLEN until after reading the array. Therefore when reading
VLEN arrays, the netCDF library will allocate the memory for the data within
each VLEN.

   <p>It is up to the user, however, to eventually free this memory. This is
not just a matter of one call to free, with the pointer to the array
of VLENs; each VLEN contains a pointer which must be freed.

<ul class="menu">
<li><a accesskey="1" href="#NF90_005fDEF_005fVLEN">NF90_DEF_VLEN</a>
<li><a accesskey="2" href="#NF90_005fINQ_005fVLEN">NF90_INQ_VLEN</a>
<li><a accesskey="3" href="#NF90_005fFREE_005fVLEN">NF90_FREE_VLEN</a>
</ul>

<div class="node">
<p><hr>
<a name="NF90_005fDEF_005fVLEN"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQ_005fVLEN">NF90_INQ_VLEN</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Variable-Length-Array">Variable Length Array</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variable-Length-Array">Variable Length Array</a>
<br>
</div>

<h4 class="subsection">5.6.1 Define a Variable Length Array (VLEN): NF90_DEF_VLEN</h4>

<p><a name="index-NF90_005fDEF_005fVLEN-100"></a><a name="index-VLEN_002c-defining-101"></a>
Use this function to define a variable length array type.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_def_vlen(ncid, name, base_typeid, xtypeid)
         integer, intent(in) :: ncid
         character (len = *), intent(in) :: name
         integer, intent(in) :: base_typeid
         integer, intent(out) :: xtypeid
         integer :: nf90_def_vlen
</pre>
     <dl>
<dt><code>NCID</code><dd>The ncid of the file to create the VLEN type in.

     <br><dt><code>NAME</code><dd>A name for the VLEN type.

     <br><dt><code>BASE_TYPEID</code><dd>The typeid of the base type of the VLEN. For example, for a VLEN of
shorts, the base type is NF90_SHORT. This can be a user defined type.

     <br><dt><code>XTYPEP</code><dd>The typeid of the new VLEN type will be set here.

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EMAXNAME</code><dd>NF90_MAX_NAME exceeded.

     <br><dt><code>NF90_ENAMEINUSE</code><dd>Name is already in use.

     <br><dt><code>NF90_EBADNAME</code><dd>Attribute or variable name contains illegal characters.

     <br><dt><code>NF90_EBADID</code><dd>ncid invalid.

     <br><dt><code>NF90_EBADGRPID</code><dd>Group ID part of ncid was invalid.

     <br><dt><code>NF90_EINVAL</code><dd>Size is invalid.

     <br><dt><code>NF90_ENOMEM</code><dd>Out of memory.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fINQ_005fVLEN"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fFREE_005fVLEN">NF90_FREE_VLEN</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fDEF_005fVLEN">NF90_DEF_VLEN</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variable-Length-Array">Variable Length Array</a>
<br>
</div>

<h4 class="subsection">5.6.2 Learning about a Variable Length Array (VLEN) Type: NF90_INQ_VLEN</h4>

<p><a name="index-NF90_005fINQ_005fVLEN-102"></a><a name="index-VLEN_002c-defining-103"></a>
Use this type to learn about a vlen.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_inq_vlen(ncid, xtype, name, datum_size, base_nc_type)
         integer, intent(in) :: ncid
         integer, intent(in) :: xtype
         character (len = *), intent(out) :: name
         integer, intent(out) :: datum_size
         integer, intent(out) :: base_nc_type
         integer :: nf90_inq_vlen
</pre>
     <dl>
<dt><code>NCID</code><dd>The ncid of the file that contains the VLEN type.

     <br><dt><code>XTYPE</code><dd>The type of the VLEN to inquire about.

     <br><dt><code>NAME</code><dd>The name of the VLEN type. The name will be NF90_MAX_NAME characters or
less.

     <br><dt><code>DATUM_SIZEP</code><dd>A pointer to a size_t, this will get the size of one element of this
vlen.

     <br><dt><code>BASE_NF90_TYPEP</code><dd>An integer that will get the type of the VLEN base type. (In other
words, what type is this a VLEN of?)

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADTYPE</code><dd>Can't find the typeid.

     <br><dt><code>NF90_EBADID</code><dd>ncid invalid.

     <br><dt><code>NF90_EBADGRPID</code><dd>Group ID part of ncid was invalid.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fFREE_005fVLEN"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQ_005fVLEN">NF90_INQ_VLEN</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variable-Length-Array">Variable Length Array</a>
<br>
</div>

<h4 class="subsection">5.6.3 Releasing Memory for a Variable Length Array (VLEN) Type: NF90_FREE_VLEN</h4>

<p><a name="index-NF90_005fFREE_005fVLEN-104"></a><a name="index-VLEN_002c-defining-105"></a>
When a VLEN is read into user memory from the file, the HDF5 library
performs memory allocations for each of the variable length arrays
contained within the VLEN structure. This memory must be freed by the
user to avoid memory leaks.

   <p>This violates the normal netCDF expectation that the user is
responsible for all memory allocation. But, with VLEN arrays, the
underlying HDF5 library allocates the memory for the user, and the user
is responsible for deallocating that memory.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_free_vlen(vl)
         character (len = *), intent(in) :: vlen
         integer :: nf90_free_vlen
     
         nf90_free_vlen = nf_free_vlen(vl)
       end function nf90_free_vlen
</pre>
     <dl>
<dt><code>VL</code><dd>The variable length array structure which is to be freed.

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADTYPE</code><dd>Can't find the typeid.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="Opaque-Type"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Enum-Type">Enum Type</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Variable-Length-Array">Variable Length Array</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Defined-Data-Types">User Defined Data Types</a>
<br>
</div>

<h3 class="section">5.7 Opaque Type Introduction</h3>

<p><a name="index-opaque-type-106"></a>
NetCDF-4 added support for the opaque type. This is not supported in
classic or 64-bit offset files.

   <p>The opaque type is a type which is a collection of objects of a known
size. (And each object is the same size). Nothing is known to netCDF
about the contents of these blobs of data, except their size in bytes,
and the name of the type.

   <p>To use an opaque type, first define it with <a href="#NF90_005fDEF_005fOPAQUE">NF90_DEF_OPAQUE</a>. If
encountering an enum type in a new data file, use <a href="#NF90_005fINQ_005fOPAQUE">NF90_INQ_OPAQUE</a>
to learn it's name and size.

<ul class="menu">
<li><a accesskey="1" href="#NF90_005fDEF_005fOPAQUE">NF90_DEF_OPAQUE</a>
<li><a accesskey="2" href="#NF90_005fINQ_005fOPAQUE">NF90_INQ_OPAQUE</a>
</ul>

<div class="node">
<p><hr>
<a name="NF90_005fDEF_005fOPAQUE"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQ_005fOPAQUE">NF90_INQ_OPAQUE</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Opaque-Type">Opaque Type</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Opaque-Type">Opaque Type</a>
<br>
</div>

<h4 class="subsection">5.7.1 Creating Opaque Types: NF90_DEF_OPAQUE</h4>

<p><a name="index-NF90_005fDEF_005fOPAQUE-107"></a>
Create an opaque type. Provide a size and a name.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_def_opaque(ncid, size, name, xtype)
         integer, intent(in) :: ncid
         integer, intent(in) :: size
         character (len = *), intent(in) :: name
         integer, intent(out) :: xtype
         integer :: nf90_def_opaque
</pre>
     <dl>
<dt><code>NCID</code><dd>The groupid where the type will be created. The type may be used
anywhere in the file, no matter what group it is in.

     <br><dt><code>NAME</code><dd>The name for this type. Must be shorter than NF90_MAX_NAME.

     <br><dt><code>SIZE</code><dd>The size of each opaque object.

     <br><dt><code>TYPEIDP</code><dd>Pointer where the new typeid for this type is returned. Use this
typeid when defining variables of this type with <a href="#NF90_005fDEF_005fVAR">NF90_DEF_VAR</a>.

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADTYPEID</code><dd>Bad typeid.

     <br><dt><code>NF90_EBADFIELDID</code><dd>Bad fieldid.

     <br><dt><code>NF90_EHDFERR</code><dd>An error was reported by the HDF5 layer.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<ul class="menu">
<li><a accesskey="1" href="#NF90_005fINQ_005fOPAQUE">NF90_INQ_OPAQUE</a>
</ul>

<div class="node">
<p><hr>
<a name="NF90_005fINQ_005fOPAQUE"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fDEF_005fOPAQUE">NF90_DEF_OPAQUE</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Opaque-Type">Opaque Type</a>
<br>
</div>

<h4 class="subsection">5.7.2 Learn About an Opaque Type: NF90_INQ_OPAQUE</h4>

<p><a name="index-NF90_005fINQ_005fOPAQUE-108"></a>
Given a typeid, get the information about an opaque type.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_inq_opaque(ncid, xtype, name, size)
         integer, intent(in) :: ncid
         integer, intent(in) :: xtype
         character (len = *), intent(out) :: name
         integer, intent(out) :: size
         integer :: nf90_inq_opaque
</pre>
     <dl>
<dt><code>NCID</code><dd>The ncid for the group containing the opaque type.

     <br><dt><code>XTYPE</code><dd>The typeid for this opaque type, as returned by NF90_DEF_COMPOUND, or
NF90_INQ_VAR.

     <br><dt><code>NAME</code><dd>The name of the opaque type will be copied here. It will
be NF90_MAX_NAME bytes or less.

     <br><dt><code>SIZEP</code><dd>The size of the opaque type will be copied here.

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADTYPEID</code><dd>Bad typeid.

     <br><dt><code>NF90_EBADFIELDID</code><dd>Bad fieldid.

     <br><dt><code>NF90_EHDFERR</code><dd>An error was reported by the HDF5 layer.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="Enum-Type"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#Opaque-Type">Opaque Type</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#User-Defined-Data-Types">User Defined Data Types</a>
<br>
</div>

<h3 class="section">5.8 Enum Type Introduction</h3>

<p><a name="index-enum-type-109"></a>
NetCDF-4 added support for the enum type. This is not supported in
classic or 64-bit offset files.

<ul class="menu">
<li><a accesskey="1" href="#NF90_005fDEF_005fENUM">NF90_DEF_ENUM</a>
<li><a accesskey="2" href="#NF90_005fINSERT_005fENUM">NF90_INSERT_ENUM</a>
<li><a accesskey="3" href="#NF90_005fINQ_005fENUM">NF90_INQ_ENUM</a>
<li><a accesskey="4" href="#NF90_005fINQ_005fENUM_005fMEMBER">NF90_INQ_ENUM_MEMBER</a>
<li><a accesskey="5" href="#NF90_005fINQ_005fENUM_005fIDENT">NF90_INQ_ENUM_IDENT</a>
</ul>

<div class="node">
<p><hr>
<a name="NF90_005fDEF_005fENUM"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINSERT_005fENUM">NF90_INSERT_ENUM</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Enum-Type">Enum Type</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Enum-Type">Enum Type</a>
<br>
</div>

<h4 class="subsection">5.8.1 Creating a Enum Type: NF90_DEF_ENUM</h4>

<p><a name="index-NF90_005fDEF_005fENUM-110"></a>
Create an enum type. Provide an ncid, a name, and a base integer
type.

   <p>After calling this function, fill out the type with repeated calls to
NF90_INSERT_ENUM (see <a href="#NF90_005fINSERT_005fENUM">NF90_INSERT_ENUM</a>). Call NF90_INSERT_ENUM once for
each value you wish to make part of the enumeration.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_def_enum(ncid, base_typeid, name, typeid)
         integer, intent(in) :: ncid
         integer, intent(in) :: base_typeid
         character (len = *), intent(in) :: name
         integer, intent(out) :: typeid
         integer :: nf90_def_enum
</pre>
     <dl>
<dt><code>NCID</code><dd>The groupid where this compound type will be created.

     <br><dt><code>BASE_TYPEID</code><dd>The base integer type for this enum. Must be one of: NF90_BYTE,
NF90_UBYTE, NF90_SHORT, NF90_USHORT, NF90_INT, NF90_UINT, NF90_INT64, NF90_UINT64.

     <br><dt><code>NAME</code><dd>The name of the new enum type.

     <br><dt><code>TYPEIDP</code><dd>The typeid of the new type will be placed here.

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADID</code><dd>Bad group id.

     <br><dt><code>NF90_ENAMEINUSE</code><dd>That name is in use. Compound type names must be unique in the data
file.

     <br><dt><code>NF90_EMAXNAME</code><dd>Name exceeds max length NF90_MAX_NAME.

     <br><dt><code>NF90_EBADNAME</code><dd>Name contains illegal characters.

     <br><dt><code>NF90_ENOTNC4</code><dd>Attempting a netCDF-4 operation on a netCDF-3 file. NetCDF-4
operations can only be performed on files defined with a create mode
which includes flag NF90_NETCDF4. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_ESTRICTNC3</code><dd>This file was created with the strict netcdf-3 flag, therefore
netcdf-4 operations are not allowed. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_EHDFERR</code><dd>An error was reported by the HDF5 layer.

     <br><dt><code>NF90_EPERM</code><dd>Attempt to write to a read-only file.

     <br><dt><code>NF90_ENOTINDEFINE</code><dd>Not in define mode.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fINSERT_005fENUM"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQ_005fENUM">NF90_INQ_ENUM</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fDEF_005fENUM">NF90_DEF_ENUM</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Enum-Type">Enum Type</a>
<br>
</div>

<h4 class="subsection">5.8.2 Inserting a Field into a Enum Type: NF90_INSERT_ENUM</h4>

<p><a name="index-NF90_005fINSERT_005fENUM-111"></a>
Insert a named member into a enum type.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_insert_enum(ncid, xtype, name, value)
         integer, intent(in) :: ncid
         integer, intent(in) :: xtype
         character (len = *), intent(in) :: name
         integer, intent(in) :: value
         integer :: nf90_insert_enum
</pre>
     <dl>
<dt><code>NCID</code><dd>The ncid of the group which contains the type.

     <br><dt><code>TYPEID</code><dd>The typeid for this enum type, as returned by nf90_def_enum, or
nf90_inq_var.

     <br><dt><code>IDENTIFIER</code><dd>The identifier of the new member.

     <br><dt><code>VALUE</code><dd>The value that is to be associated with this member.

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADID</code><dd>Bad group id.

     <br><dt><code>NF90_ENAMEINUSE</code><dd>That name is in use. Field names must be unique within a enum type.

     <br><dt><code>NF90_EMAXNAME</code><dd>Name exceed max length NF90_MAX_NAME.

     <br><dt><code>NF90_EBADNAME</code><dd>Name contains illegal characters.

     <br><dt><code>NF90_ENOTNC4</code><dd>Attempting a netCDF-4 operation on a netCDF-3 file. NetCDF-4
operations can only be performed on files defined with a create mode
which includes flag NF90_NETCDF4. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_ESTRICTNC3</code><dd>This file was created with the strict netcdf-3 flag, therefore
netcdf-4 operations are not allowed. (see <a href="#NF90_005fOPEN">NF90_OPEN</a>).

     <br><dt><code>NF90_EHDFERR</code><dd>An error was reported by the HDF5 layer.

     <br><dt><code>NF90_ENOTINDEFINE</code><dd>Not in define mode.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fINQ_005fENUM"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQ_005fENUM_005fMEMBER">NF90_INQ_ENUM_MEMBER</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINSERT_005fENUM">NF90_INSERT_ENUM</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Enum-Type">Enum Type</a>
<br>
</div>

<h4 class="subsection">5.8.3 Learn About a Enum Type: NF90_INQ_ENUM</h4>

<p><a name="index-NF90_005fINQ_005fENUM-112"></a>
Get information about a user-defined enumeration type.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_inq_enum(ncid, xtype, name, base_nc_type, base_size, num_members)
         integer, intent(in) :: ncid
         integer, intent(in) :: xtype
         character (len = *), intent(out) :: name
         integer, intent(out) :: base_nc_type
         integer, intent(out) :: base_size
         integer, intent(out) :: num_members
         integer :: nf90_inq_enum
</pre>
     <dl>
<dt><code>NCID</code><dd>The group ID of the group which holds the enum type.

     <br><dt><code>XTYPE</code><dd>The typeid for this enum type, as returned by NF90_DEF_ENUM, or
NF90_INQ_VAR.

     <br><dt><code>NAME</code><dd>Character array which will get the name. It will have a maximum length
of NF90_MAX_NAME.

     <br><dt><code>BASE_NF90_TYPE</code><dd>An integer which will get the base integer type of this enum.

     <br><dt><code>BASE_SIZE</code><dd>An integer which will get the size (in bytes) of the base integer type
of this enum.

     <br><dt><code>NUM_MEMBERS</code><dd>An integer which will get the number of members defined for this
enumeration type.

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADTYPEID</code><dd>Bad type id.

     <br><dt><code>NF90_EHDFERR</code><dd>An error was reported by the HDF5 layer.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fINQ_005fENUM_005fMEMBER"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQ_005fENUM_005fIDENT">NF90_INQ_ENUM_IDENT</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQ_005fENUM">NF90_INQ_ENUM</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Enum-Type">Enum Type</a>
<br>
</div>

<h4 class="subsection">5.8.4 Learn the Name of a Enum Type: nf90_inq_enum_member</h4>

<p><a name="index-nf90_005finq_005fenum_005fmember-113"></a>
Get information about a member of an enum type.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_inq_enum_member(ncid, xtype, idx, name, value)
         integer, intent(in) :: ncid
         integer, intent(in) :: xtype
         integer, intent(in) :: idx
         character (len = *), intent(out) :: name
         integer, intent(in) :: value
         integer :: nf90_inq_enum_member
</pre>
     <dl>
<dt><code>NCID</code><dd>The groupid where this enum type exists.

     <br><dt><code>XTYPE</code><dd>The typeid for this enum type.

     <br><dt><code>IDX</code><dd>The one-based index number for the member of interest.

     <br><dt><code>NAME</code><dd>A character array which will get the name of the member. It will have
a maximum length of NF90_MAX_NAME.

     <br><dt><code>VALUE</code><dd>An integer that will get the value associated with this member.

   </dl>

<h3 class="heading">Errors</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADTYPEID</code><dd>Bad type id.

     <br><dt><code>NF90_EHDFERR</code><dd>An error was reported by the HDF5 layer.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fINQ_005fENUM_005fIDENT"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQ_005fENUM_005fMEMBER">NF90_INQ_ENUM_MEMBER</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Enum-Type">Enum Type</a>
<br>
</div>

<h4 class="subsection">5.8.5 Learn the Name of a Enum Type: NF90_INQ_ENUM_IDENT</h4>

<p><a name="index-NF90_005fINQ_005fENUM_005fIDENT-114"></a>
Get the name which is associated with an enum member value.

   <p>This is similar to NF90_INQ_ENUM_MEMBER, but instead of using the index
of the member, you use the value of the member.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_inq_enum_ident(ncid, xtype, value, idx)
         integer, intent(in) :: ncid
         integer, intent(in) :: xtype
         integer, intent(in) :: value
         integer, intent(out) :: idx
         integer :: nf90_inq_enum_ident
</pre>
     <dl>
<dt><code>NCID</code><dd>The groupid where this enum type exists.

     <br><dt><code>XTYPE</code><dd>The typeid for this enum type.

     <br><dt><code>VALUE</code><dd>The value for which an identifier is sought.

     <br><dt><code>IDENTIFIER</code><dd>A character array that will get the identifier. It will have a maximum
length of NF90_MAX_NAME.

   </dl>

<h3 class="heading">Return Code</h3>

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_EBADTYPEID</code><dd>Bad type id, or not an enum type.

     <br><dt><code>NF90_EHDFERR</code><dd>An error was reported by the HDF5 layer.

     <br><dt><code>NF90_EINVAL</code><dd>The value was not found in the enum.

</dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="Variables"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Attributes">Attributes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#User-Defined-Data-Types">User Defined Data Types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="chapter">6 Variables</h2>

<ul class="menu">
<li><a accesskey="1" href="#Variables-Introduction">Variables Introduction</a>
<li><a accesskey="2" href="#Language_002dTypes">Language-Types</a>
<li><a accesskey="3" href="#NF90_005fDEF_005fVAR">NF90_DEF_VAR</a>:                 Create a Variable
<li><a accesskey="4" href="#NF90_005fDEF_005fVAR_005fCHUNKING">NF90_DEF_VAR_CHUNKING</a>:        Set Var Chunking Parameters
<li><a accesskey="5" href="#NF90_005fINQ_005fVAR_005fCHUNKING">NF90_INQ_VAR_CHUNKING</a>:        Get Var Chunking Parameters
<li><a accesskey="6" href="#NF90_005fDEF_005fVAR_005fDEFLATE">NF90_DEF_VAR_DEFLATE</a>:         Set Var Compression Parameters
<li><a accesskey="7" href="#NF90_005fINQ_005fVAR_005fDEFLATE">NF90_INQ_VAR_DEFLATE</a>:         Get Var Compression Parameters
<li><a accesskey="8" href="#NF90_005fDEF_005fVAR_005fFLETCHER32">NF90_DEF_VAR_FLETCHER32</a>:      Set Var Fletcher32 Filter
<li><a accesskey="9" href="#NF90_005fINQ_005fVAR_005fFLETCHER32">NF90_INQ_VAR_FLETCHER32</a>:      Get Var Fletcher32 Filter
<li><a href="#NF90_005fDEF_005fVAR_005fENDIAN">NF90_DEF_VAR_ENDIAN</a>:          Set Var Endianness
<li><a href="#NF90_005fINQ_005fVAR_005fENDIAN">NF90_INQ_VAR_ENDIAN</a>:          Get Var Endianness
<li><a href="#NF90_005fINQUIRE_005fVARIABLE">NF90_INQUIRE_VARIABLE</a>:        Get Var Metadata
<li><a href="#NF90_005fPUT_005fVAR">NF90_PUT_VAR</a>:                 Write data
<li><a href="#NF90_005fGET_005fVAR">NF90_GET_VAR</a>:                 Read data
<li><a href="#Reading-and-Writing-Character-String-Values">Reading and Writing Character String Values</a>
<li><a href="#Fill-Values">Fill Values</a>:                  What's Written Where there's No Data? 
<li><a href="#NF90_005fRENAME_005fVAR">NF90_RENAME_VAR</a>
</ul>

<div class="node">
<p><hr>
<a name="Variables-Introduction"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Language_002dTypes">Language-Types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Variables">Variables</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variables">Variables</a>
<br>
</div>

<h3 class="section">6.1 Variables Introduction</h3>

<p>Variables for a netCDF dataset are defined when the dataset is
created, while the netCDF dataset is in define mode. Other variables
may be added later by reentering define mode. A netCDF variable has a
name, a type, and a shape, which are specified when it is defined. A
variable may also have values, which are established later in data
mode.

   <p>Ordinarily, the name, type, and shape are fixed when the variable is
first defined. The name may be changed, but the type and shape of a
variable cannot be changed. However, a variable defined in terms of
the unlimited dimension can grow without bound in that dimension.

   <p>A netCDF variable in an open netCDF dataset is referred to by a small
integer called a variable ID.

   <p>Variable IDs reflect the order in which variables were defined within
a netCDF dataset. Variable IDs are 1, 2, 3,..., in the order in which
the variables were defined. A function is available for getting the
variable ID from the variable name and vice-versa.

   <p>Attributes (see <a href="#Attributes">Attributes</a>) may be associated with a variable to
specify such properties as units.

   <p>Operations supported on variables are:
     <ul>
<li>Create a variable, given its name, data type, and shape.

     <li>Get a variable ID from its name.

     <li>Get a variable's name, data type, shape, and number of attributes from
its ID.

     <li>Put a data value into a variable, given variable ID, indices, and
value.

     <li>Put an array of values into a variable, given variable ID, corner
indices, edge lengths, and a block of values.

     <li>Put a subsampled or mapped array-section of values into a variable,
given variable ID, corner indices, edge lengths, stride vector, index
mapping vector, and a block of values.

     <li>Get a data value from a variable, given variable ID and indices.

     <li>Get an array of values from a variable, given variable ID, corner
indices, and edge lengths.

     <li>Get a subsampled or mapped array-section of values from a variable,
given variable ID, corner indices, edge lengths, stride vector, and
index mapping vector.

     <li>Rename a variable. 
</ul>

<div class="node">
<p><hr>
<a name="Language_002dTypes"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fDEF_005fVAR">NF90_DEF_VAR</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Variables-Introduction">Variables Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variables">Variables</a>
<br>
</div>

<h3 class="section">6.2 Language Types Corresponding to netCDF external data types</h3>

<p>The following table gives the netCDF external data types and the
corresponding type constants for defining variables in the FORTRAN
interface:

   <p><table summary=""><tr align="left"><td valign="top" width="25%">Type </td><td valign="top" width="60%">FORTRAN API Mnemonic </td><td valign="top" width="15%">Bits

<p><br></td></tr><tr align="left"><td valign="top" width="25%">byte
</td><td valign="top" width="60%">NF90_BYTE
</td><td valign="top" width="15%">8

<p><br></td></tr><tr align="left"><td valign="top" width="25%">char
</td><td valign="top" width="60%">NF90_CHAR
</td><td valign="top" width="15%">8

<p><br></td></tr><tr align="left"><td valign="top" width="25%">short
</td><td valign="top" width="60%">NF90_SHORT
</td><td valign="top" width="15%">16

<p><br></td></tr><tr align="left"><td valign="top" width="25%">int
</td><td valign="top" width="60%">NF90_INT
</td><td valign="top" width="15%">32

<p><br></td></tr><tr align="left"><td valign="top" width="25%">float
</td><td valign="top" width="60%">NF90_FLOAT
</td><td valign="top" width="15%">32

<p><br></td></tr><tr align="left"><td valign="top" width="25%">double
</td><td valign="top" width="60%">NF90_DOUBLE
</td><td valign="top" width="15%">64
   <br></td></tr></table>

   <p>The first column gives the netCDF external data type, which is the
same as the CDL data type. The next column gives the corresponding
Fortran 90 parameter for use in netCDF functions (the parameters are
defined in the netCDF Fortran 90 module netcdf.f90). The last column
gives the number of bits used in the external representation of values
of the corresponding type.

   <p>Note that there are no netCDF types corresponding to 64-bit integers
or to characters wider than 8 bits in the current version of the
netCDF library.

<div class="node">
<p><hr>
<a name="NF90_005fDEF_005fVAR"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fDEF_005fVAR_005fCHUNKING">NF90_DEF_VAR_CHUNKING</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Language_002dTypes">Language-Types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variables">Variables</a>
<br>
</div>

<h3 class="section">6.3 Create a Variable: <code>NF90_DEF_VAR</code></h3>

<p><a name="index-NF90_005fDEF_005fVAR-115"></a><a name="index-NF90_005fDEF_005fVAR_002c-example-116"></a>
The function NF90_DEF_VAR adds a new variable to an open netCDF dataset
in define mode. It returns (as an argument) a variable ID, given the
netCDF ID, the variable name, the variable type, the number of
dimensions, and a list of the dimension IDs.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_def_var(ncid, name, xtype, dimids, varid)
        integer,               intent( in) :: ncid
        character (len = *),   intent( in) :: name
        integer,               intent( in) :: xtype
        integer, dimension(:), intent( in) :: dimids
        integer,               intent(out) :: varid
        integer                            :: nf90_def_var
</pre>
     <dl>
<dt><code>ncid</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>name</code><dd>Variable name. Must begin with an alphabetic character, followed by
zero or more alphanumeric characters including the underscore
('_'). Case is significant.

     <br><dt><code>xtype</code><dd>One of the set of predefined netCDF external data types. The type of
this parameter, NF90_TYPE, is defined in the netCDF header file. The
valid netCDF external data types are NF90_BYTE, NF90_CHAR, NF90_SHORT,
NF90_INT, NF90_FLOAT, and NF90_DOUBLE. If the file is a NetCDF-4/HDF5 file,
the additional types NF_UBYTE, NF_USHORT, NF_UINT, NF_INT64,
NF_UINT64, and NF_STRING may be used, as well as a user defined type
ID.

     <br><dt><code>dimids</code><dd>Vector of dimension IDs corresponding to the variable dimensions. For
example, a vector of 2 dimension IDs specifies a matrix, 1 specifies a
vector, and 0 means the variable is a scalar with no dimensions.  For
expanded model netCDF4/HDF5 files, there may be any number of
unlimited dimensions, and they may be used in any element of the
dimids array.

     <p>If the ID of the unlimited dimension is included, it must
be first.  This argument is optional, and if absent specifies a scalar
with no dimensions.

     <br><dt><code>varid</code><dd>Returned variable ID. 
</dl>

<h3 class="heading">Errors</h3>

<p>NF90_DEF_VAR returns the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:

     <ul>
<li>The netCDF dataset is not in define mode.

     <li>The specified variable name is the name of another existing variable.

     <li>The specified type is not a valid netCDF type.

     <li>The specified number of dimensions is negative or more than the
constant NF90_MAX_VAR_DIMS, the maximum number of dimensions permitted
for a netCDF variable.

     <li>One or more of the dimension IDs in the list of dimensions is not a
valid dimension ID for the netCDF dataset.

     <li>The number of variables would exceed the constant NF90_MAX_VARS, the
maximum number of variables permitted in a netCDF dataset.

     <li>The specified netCDF ID does not refer to an open netCDF dataset. 
</ul>

<h3 class="heading">Example</h3>

<p>Here is an example using NF90_DEF_VAR to create a variable named rh of
type double with three dimensions, time, lat, and lon in a new netCDF
dataset named foo.nc:

<pre class="example">      use netcdf
      implicit none
      integer :: status, ncid
      integer :: LonDimId, LatDimId, TimeDimId
      integer :: RhVarId
      ...
      status = nf90_create("foo.nc", nf90_NoClobber, ncid)
      if(status /= nf90_NoErr) call handle_error(status)
      ...
      ! Define the dimensions
      status = nf90_def_dim(ncid, "lat", 5, LatDimId)
      if(status /= nf90_NoErr) call handle_error(status)
      status = nf90_def_dim(ncid, "lon", 10, LonDimId)
      if(status /= nf90_NoErr) call handle_error(status)
      status = nf90_def_dim(ncid, "time", nf90_unlimited, TimeDimId)
      if(status /= nf90_NoErr) call handle_error(status)
      ...
      ! Define the variable
      status = nf90_def_var(ncid, "rh", nf90_double, &amp;
                            (/ LonDimId, LatDimID, TimeDimID /), RhVarId)
      if(status /= nf90_NoErr) call handle_error(status)
</pre>
   <div class="node">
<p><hr>
<a name="NF90_005fDEF_005fVAR_005fCHUNKING"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQ_005fVAR_005fCHUNKING">NF90_INQ_VAR_CHUNKING</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fDEF_005fVAR">NF90_DEF_VAR</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variables">Variables</a>
<br>
</div>

<h3 class="section">6.4 Define Chunking Parameters for a Variable: <code>NF90_DEF_VAR_CHUNKING</code></h3>

<p><a name="index-NF90_005fDEF_005fVAR_005fCHUNKING-117"></a><a name="index-chunking-118"></a><a name="index-variables_002c-chunking-119"></a>
The function NF90_DEF_VAR_CHUNKING sets the chunking parameters for a
variable in a netCDF-4 file.

   <p>The total size the chunk must be less than 4 GiB. That is, the product
of all chunksizes and the size of the data (or the size of nc_vlen_t
for VLEN types) must be less than 4 GiB.

   <p>This function must be called after the variable is defined, but before
nf_enddef is called.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_def_var_chunking(ncid, varid, contiguous, chunksizes)
         integer, intent(in) :: ncid
         integer, intent(in) :: varid
         integer, intent(in) :: contiguous
         integer, dimension(:), intent(in) :: chunksizes
         integer :: nf90_def_var_chunking
</pre>
     <dl>
<dt><code>ncid</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>varid</code><dd>Variable ID.

     <br><dt><code>contiguous</code><dd>If non-zero, then contiguous storage is used for this
variable. Variables with one or more unlimited dimensions cannot use
contiguous storage. If contiguous storage is turned on, the chunksizes
parameter is ignored.

     <br><dt><code>chunksizes</code><dd>An array of chunk sizes. The array must have the one chunksize for
each dimension in the variable. If the contiguous parameter is set,
then the chunksizes parameter is ignored.

   </dl>

<h3 class="heading">Errors</h3>

<p>NF90_DEF_VAR_CHUNKING returns the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error.

   <p>Possible return codes include:

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_BADID</code><dd>Bad ncid.

     <br><dt><code>NF90_ENOTNC4</code><dd>Not a netCDF-4 file.

     <br><dt><code>NF90_ENOTVAR</code><dd>Can't find this variable.

     <br><dt><code>NF90_ELATEDEF</code><dd>This variable has already been the subject of a NC_ENDDEF call. In
netCDF-4 files NC_ENDDEF will be called automatically for any data
read or write. Once enddef has been called, it is impossible to set
the chunking for a variable.

     <br><dt><code>NF90_ENOTINDEFINE</code><dd>Not in define mode. This is returned for netCDF classic or 64-bit
offset files, or for netCDF-4 files, when they were been created with
NF90_STRICT_NC3 flag. (see <a href="#NF90_005fCREATE">NF90_CREATE</a>).

     <br><dt><code>NF90_ESTRICTNC3</code><dd>Trying to create a var some place other than the root group in a
netCDF file with NF90_STRICT_NC3 turned on.

   </dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fINQ_005fVAR_005fCHUNKING"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fDEF_005fVAR_005fDEFLATE">NF90_DEF_VAR_DEFLATE</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fDEF_005fVAR_005fCHUNKING">NF90_DEF_VAR_CHUNKING</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variables">Variables</a>
<br>
</div>

<h3 class="section">6.5 Learn About Chunking Parameters for a Variable: <code>NF90_INQ_VAR_CHUNKING</code></h3>

<p><a name="index-NF90_005fINQ_005fVAR_005fCHUNKING-120"></a>
The function NF90_INQ_VAR_CHUNKING returns the chunking settings for a
variable in a netCDF-4 file.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_inq_var_chunking(ncid, varid, contiguous, chunksizes)
         integer, intent(in) :: ncid
         integer, intent(in) :: varid
         integer, intent(out) :: contiguous
         integer, dimension(:), intent(out) :: chunksizes
         integer :: nf90_inq_var_chunking
</pre>
     <dl>
<dt><code>NCID</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>VARID</code><dd>Variable ID.

     <br><dt><code>CONTIGUOUS</code><dd>Set to 1 if this variable uses contiguous storage, 0 if it used
chunked storage.

     <br><dt><code>CHUNKSIZES</code><dd>An array of chunk sizes. The array must have the one element for
each dimension in the variable.

   </dl>

<h3 class="heading">Errors</h3>

<p>NF90_INQ_VAR_CHUNKING returns the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error.

   <p>Possible return codes include:

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_BADID</code><dd>Bad ncid.

     <br><dt><code>NF90_ENOTNC4</code><dd>Not a netCDF-4 file.

     <br><dt><code>NF90_ENOTVAR</code><dd>Can't find this variable.

   </dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fDEF_005fVAR_005fDEFLATE"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQ_005fVAR_005fDEFLATE">NF90_INQ_VAR_DEFLATE</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQ_005fVAR_005fCHUNKING">NF90_INQ_VAR_CHUNKING</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variables">Variables</a>
<br>
</div>

<h3 class="section">6.6 Define Compression Parameters for a Variable: <code>NF90_DEF_VAR_DEFLATE</code></h3>

<p><a name="index-NF90_005fDEF_005fVAR_005fDEFLATE-121"></a><a name="index-deflate-122"></a><a name="index-variables_002c-setting-deflate-123"></a><a name="index-compression_002c-setting-parameters-124"></a>
The function NF90_DEF_VAR_DEFLATE sets the deflate parameters for a
variable in a netCDF-4 file.

   <p>This function must be called after the variable is defined, but before
NC_ENDDEF is called.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_def_var_deflate(ncid, varid, shuffle, deflate, deflate_level)
         integer, intent(in) :: ncid
         integer, intent(in) :: varid
         integer, intent(in) :: shuffle
         integer, intent(in) :: deflate
         integer, intent(in) :: deflate_level
         integer :: nf90_def_var_deflate
</pre>
     <dl>
<dt><code>NCID</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>VARID</code><dd>Variable ID.

     <br><dt><code>SHUFFLE</code><dd>If non-zero, turn on the shuffle filter.

     <br><dt><code>DEFLATE</code><dd>If non-zero, turn on the deflate filter at the level specified by the
deflate_level parameter.

     <br><dt><code>DEFLATE_LEVEL</code><dd>If the deflate parameter is non-zero, set the deflate level to this
value. Must be between 0 and 9.

   </dl>

<h3 class="heading">Errors</h3>

<p>NF90_DEF_VAR_DEFLATE returns the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error.

   <p>Possible return codes include:

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_BADID</code><dd>Bad ncid.

     <br><dt><code>NF90_ENOTNC4</code><dd>Not a netCDF-4 file.

     <br><dt><code>NF90_ENOTVAR</code><dd>Can't find this variable.

     <br><dt><code>NF90_ELATEDEF</code><dd>This variable has already been the subject of a NC_ENDDEF call. In
netCDF-4 files NC_ENDDEF will be called automatically for any data
read or write. Once enddef has been called, it is impossible to set
the deflate for a variable.

     <br><dt><code>NF90_ENOTINDEFINE</code><dd>Not in define mode. This is returned for netCDF classic or 64-bit
offset files, or for netCDF-4 files, when they were been created with
NF90_STRICT_NC3 flag. (see <a href="#NF90_005fCREATE">NF90_CREATE</a>).

     <br><dt><code>NF90_EPERM</code><dd>Attempt to create object in read-only file.

     <br><dt><code>NF90_EINVAL</code><dd>Invalid deflate_level. The deflate level must be between 0 and 9,
inclusive.

   </dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fINQ_005fVAR_005fDEFLATE"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fDEF_005fVAR_005fFLETCHER32">NF90_DEF_VAR_FLETCHER32</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fDEF_005fVAR_005fDEFLATE">NF90_DEF_VAR_DEFLATE</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variables">Variables</a>
<br>
</div>

<h3 class="section">6.7 Learn About Deflate Parameters for a Variable: <code>NF90_INQ_VAR_DEFLATE</code></h3>

<p><a name="index-NF90_005fINQ_005fVAR_005fDEFLATE-125"></a>
The function NF90_INQ_VAR_DEFLATE returns the deflate settings for a
variable in a netCDF-4 file.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_inq_var_deflate(ncid, varid, shuffle, deflate, deflate_level)
         integer, intent(in) :: ncid
         integer, intent(in) :: varid
         integer, intent(out) :: shuffle
         integer, intent(out) :: deflate
         integer, intent(out) :: deflate_level
         integer :: nf90_inq_var_deflate
</pre>
     <dl>
<dt><code>NCID</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>VARID</code><dd>Variable ID.

     <br><dt><code>SHUFFLE</code><dd>NF90_INQ_VAR_DEFLATE will set this to a 1 if the shuffle filter is
turned on for this variable, and a 0 otherwise.

     <br><dt><code>DEFLATE</code><dd>NF90_INQ_VAR_DEFLATE will set this to a 1 if the deflate filter is
turned on for this variable, and a 0 otherwise.

     <br><dt><code>DEFLATE_LEVEL</code><dd>NF90_INQ_VAR_DEFLATE function will write the deflate_level here, if
deflate is in use.

   </dl>

<h3 class="heading">Errors</h3>

<p>NF90_INQ_VAR_DEFLATE returns the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error.

   <p>Possible return codes include:

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_BADID</code><dd>Bad ncid.

     <br><dt><code>NF90_ENOTNC4</code><dd>Not a netCDF-4 file.

     <br><dt><code>NF90_ENOTVAR</code><dd>Can't find this variable.

   </dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fDEF_005fVAR_005fFLETCHER32"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQ_005fVAR_005fFLETCHER32">NF90_INQ_VAR_FLETCHER32</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQ_005fVAR_005fDEFLATE">NF90_INQ_VAR_DEFLATE</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variables">Variables</a>
<br>
</div>

<h3 class="section">6.8 Define Fletcher32 Parameters for a Variable: <code>NF90_DEF_VAR_FLETCHER32</code></h3>

<p><a name="index-NF90_005fDEF_005fVAR_005fFLETCHER32-126"></a><a name="index-fletcher32-127"></a><a name="index-variables_002c-fletcher32-128"></a>
The function NF90_DEF_VAR_FLETCHER32 sets the fletcher32 parameters for a
variable in a netCDF-4 file.

   <p>This function must be called after the variable is defined, but before
NC_ENDDEF is called.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_def_var_fletcher32(ncid, varid, fletcher32)
         integer, intent(in) :: ncid
         integer, intent(in) :: varid
         integer, intent(in) :: fletcher32
         integer :: nf90_def_var_fletcher32
</pre>
     <dl>
<dt><code>NCID</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>VARID</code><dd>Variable ID.

     <br><dt><code>FLETCHER32</code><dd>If this is non-zero, fletcher32 checksums will be turned on for this
variable.

   </dl>

<h3 class="heading">Errors</h3>

<p>NF90_DEF_VAR_FLETCHER32 returns the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error.

   <p>Possible return codes include:

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_BADID</code><dd>Bad ncid.

     <br><dt><code>NF90_ENOTNC4</code><dd>Not a netCDF-4 file.

     <br><dt><code>NF90_ENOTVAR</code><dd>Can't find this variable.

     <br><dt><code>NF90_ELATEDEF</code><dd>This variable has already been the subject of a NC_ENDDEF call. In
netCDF-4 files NC_ENDDEF will be called automatically for any data
read or write. Once enddef has been called, it is impossible to set
the fletcher32 for a variable.

     <br><dt><code>NF90_ENOTINDEFINE</code><dd>Not in define mode. This is returned for netCDF classic or 64-bit
offset files, or for netCDF-4 files, when they were been created with
NF90_STRICT_NC3 flag. (see <a href="#NF90_005fCREATE">NF90_CREATE</a>).

     <br><dt><code>NF90_EPERM</code><dd>Attempt to create object in read-only file.

   </dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fINQ_005fVAR_005fFLETCHER32"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fDEF_005fVAR_005fENDIAN">NF90_DEF_VAR_ENDIAN</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fDEF_005fVAR_005fFLETCHER32">NF90_DEF_VAR_FLETCHER32</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variables">Variables</a>
<br>
</div>

<h3 class="section">6.9 Learn About Fletcher32 Parameters for a Variable: <code>NF90_INQ_VAR_FLETCHER32</code></h3>

<p><a name="index-NF90_005fINQ_005fVAR_005fFLETCHER32-129"></a>
The function NF90_INQ_VAR_FLETCHER32 returns the fletcher32 settings for a
variable in a netCDF-4 file.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_inq_var_fletcher32(ncid, varid, fletcher32)
         integer, intent(in) :: ncid
         integer, intent(in) :: varid
         integer, intent(out) :: fletcher32
         integer :: nf90_inq_var_fletcher32
</pre>
     <dl>
<dt><code>NCID</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>VARID</code><dd>Variable ID.

     <br><dt><code>FLETCHER32</code><dd>NF90_INQ_VAR_FLETCHER32 will set this to 1 if the fletcher32 filter is
turned on for this variable, and 0 if it is not.

   </dl>

<h3 class="heading">Errors</h3>

<p>NF90_INQ_VAR_FLETCHER32 returns the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error.

   <p>Possible return codes include:

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_BADID</code><dd>Bad ncid.

     <br><dt><code>NF90_ENOTNC4</code><dd>Not a netCDF-4 file.

     <br><dt><code>NF90_ENOTVAR</code><dd>Can't find this variable.

   </dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fDEF_005fVAR_005fENDIAN"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQ_005fVAR_005fENDIAN">NF90_INQ_VAR_ENDIAN</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQ_005fVAR_005fFLETCHER32">NF90_INQ_VAR_FLETCHER32</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variables">Variables</a>
<br>
</div>

<h3 class="section">6.10 Define Endianness of a Variable: <code>NF90_DEF_VAR_ENDIAN</code></h3>

<p><a name="index-NF90_005fDEF_005fVAR_005fENDIAN-130"></a><a name="index-endianness-131"></a><a name="index-big_002dendian-132"></a><a name="index-little_002dendian-133"></a><a name="index-variables_002c-endian-134"></a>
The function NF90_DEF_VAR_ENDIAN sets the endianness for a variable in a
netCDF-4 file.

   <p>This function must be called after the variable is defined, but before
NC_ENDDEF is called.

   <p>By default, netCDF-4 variables are in native endianness. That is, they
are big-endian on a big-endian machine, and little-endian on a little
endian machine.

   <p>In some cases a user might wish to change from native endianness to
either big or little-endianness. This function allows them to do that.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_def_var_endian(ncid, varid, endian)
         integer, intent(in) :: ncid
         integer, intent(in) :: varid
         integer, intent(in) :: endian
         integer :: nf90_def_var_endian
</pre>
     <dl>
<dt><code>NCID</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>VARID</code><dd>Variable ID.

     <br><dt><code>ENDIAN</code><dd>Set to NF90_ENDIAN_NATIVE for native endianness. (This is the
default). Set to NF90_ENDIAN_LITTLE for little endian, or NF90_ENDIAN_BIG
for big endian.

   </dl>

<h3 class="heading">Errors</h3>

<p>NF90_DEF_VAR_ENDIAN returns the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error.

   <p>Possible return codes include:

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_BADID</code><dd>Bad ncid.

     <br><dt><code>NF90_ENOTNC4</code><dd>Not a netCDF-4 file.

     <br><dt><code>NF90_ENOTVAR</code><dd>Can't find this variable.

     <br><dt><code>NF90_ELATEDEF</code><dd>This variable has already been the subject of a NC_ENDDEF call. In
netCDF-4 files NC_ENDDEF will be called automatically for any data
read or write. Once enddef has been called, it is impossible to set
the endianness of a variable.

     <br><dt><code>NF90_ENOTINDEFINE</code><dd>Not in define mode. This is returned for netCDF classic or 64-bit
offset files, or for netCDF-4 files, when they were been created with
NF90_STRICT_NC3 flag, and the file is not in define
mode. (see <a href="#NF90_005fCREATE">NF90_CREATE</a>).

     <br><dt><code>NF90_EPERM</code><dd>Attempt to create object in read-only file.

   </dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fINQ_005fVAR_005fENDIAN"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQUIRE_005fVARIABLE">NF90_INQUIRE_VARIABLE</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fDEF_005fVAR_005fENDIAN">NF90_DEF_VAR_ENDIAN</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variables">Variables</a>
<br>
</div>

<h3 class="section">6.11 Learn About Endian Parameters for a Variable: <code>NF90_INQ_VAR_ENDIAN</code></h3>

<p><a name="index-NF90_005fINQ_005fVAR_005fENDIAN-135"></a>
The function NF90_INQ_VAR_ENDIAN returns the endianness settings for a
variable in a netCDF-4 file.

<h3 class="heading">Usage</h3>

<pre class="example">       function nf90_inq_var_endian(ncid, varid, endian)
         integer, intent(in) :: ncid
         integer, intent(in) :: varid
         integer, intent(out) :: endian
         integer :: nf90_inq_var_endian
</pre>
     <dl>
<dt><code>NCID</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>VARID</code><dd>Variable ID.

     <br><dt><code>ENDIAN</code><dd>NF90_INQ_VAR_ENDIAN will set this to NF90_ENDIAN_LITTLE if this variable
is stored in little-endian format, NF90_ENDIAN_BIG if it is stored in
big-endian format, and NF90_ENDIAN_NATIVE if the endianness is not set,
and the variable is not created yet.

   </dl>

<h3 class="heading">Errors</h3>

<p>NF90_INQ_VAR_ENDIAN returns the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error.

   <p>Possible return codes include:

     <dl>
<dt><code>NF90_NOERR</code><dd>No error.

     <br><dt><code>NF90_BADID</code><dd>Bad ncid.

     <br><dt><code>NF90_ENOTNC4</code><dd>Not a netCDF-4 file.

     <br><dt><code>NF90_ENOTVAR</code><dd>Can't find this variable.

   </dl>

<h3 class="heading">Example</h3>

<pre class="example"></pre>
<div class="node">
<p><hr>
<a name="NF90_005fINQUIRE_005fVARIABLE"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fPUT_005fVAR">NF90_PUT_VAR</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQ_005fVAR_005fENDIAN">NF90_INQ_VAR_ENDIAN</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variables">Variables</a>
<br>
</div>

<h3 class="section">6.12 Get Information about a Variable from Its ID: NF90_INQUIRE_VARIABLE</h3>

<p><a name="index-NF90_005fINQUIRE_005fVARIABLE-136"></a><a name="index-NF90_005fINQUIRE_005fVARIABLE-_002c-example-137"></a>
NF90_INQUIRE_VARIABLE returns information about a netCDF variable
given its ID. Information about a variable includes its name, type,
number of dimensions, a list of dimension IDs describing the shape of
the variable, and the number of variable attributes that have been
assigned to the variable.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_inquire_variable(ncid, varid, name, xtype, ndims, dimids, nAtts)
        integer,                         intent( in) :: ncid, varid
        character (len = *),   optional, intent(out) :: name
        integer,               optional, intent(out) :: xtype, ndims
        integer, dimension(*), optional, intent(out) :: dimids
        integer,               optional, intent(out) :: nAtts
        integer                                      :: nf90_inquire_variable
</pre>
     <dl>
<dt><code>ncid</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>varid</code><dd>Variable ID.

     <br><dt><code>name</code><dd>Returned variable name. The caller must allocate space for the
returned name. The maximum possible length, in characters, of a
variable name is given by the predefined constant NF90_MAX_NAME.

     <br><dt><code>xtype</code><dd>Returned variable type, one of the set of predefined netCDF external
data types. The type of this parameter, NF90_TYPE, is defined in the
netCDF header file. The valid netCDF external data types are NF90_BYTE,
NF90_CHAR, NF90_SHORT, NF90_INT, NF90_FLOAT, AND NF90_DOUBLE.

     <br><dt><code>ndims</code><dd>Returned number of dimensions the variable was defined as using. For
example, 2 indicates a matrix, 1 indicates a vector, and 0 means the
variable is a scalar with no dimensions.

     <br><dt><code>dimids</code><dd>Returned vector of *ndimsp dimension IDs corresponding to the
variable dimensions. The caller must allocate enough space for a
vector of at least *ndimsp integers to be returned. The maximum
possible number of dimensions for a variable is given by the
predefined constant NF90_MAX_VAR_DIMS.

     <br><dt><code>natts</code><dd>Returned number of variable attributes assigned to this variable.

   </dl>

   <p>These functions return the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:

     <ul>
<li>The variable ID is invalid for the specified netCDF dataset.

     <li>The specified netCDF ID does not refer to an open netCDF dataset.

   </ul>

<h3 class="heading">Example</h3>

<p>Here is an example using NF90_INQ_VAR to find out about a variable named
rh in an existing netCDF dataset named foo.nc:

<pre class="example">         use netcdf
         implicit none
         integer                            :: status, ncid, &amp;
                                               RhVarId       &amp;
                                               numDims, numAtts
      integer, dimension(nf90_max_var_dims) :: rhDimIds
      ...
      status = nf90_open("foo.nc", nf90_NoWrite, ncid)
      if(status /= nf90_NoErr) call handle_error(status)
      ...
      status = nf90_inq_varid(ncid, "rh", RhVarId)
      if(status /= nf90_NoErr) call handle_err(status)
      status = nf90_inquire_variable(ncid, RhVarId, ndims = numDims, natts = numAtts)
      if(status /= nf90_NoErr) call handle_err(status)
      status = nf90_inquire_variable(ncid, RhVarId, dimids = rhDimIds(:numDims))
      if(status /= nf90_NoErr) call handle_err(status)
</pre>
   <div class="node">
<p><hr>
<a name="NF90_005fPUT_005fVAR"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fGET_005fVAR">NF90_GET_VAR</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQUIRE_005fVARIABLE">NF90_INQUIRE_VARIABLE</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variables">Variables</a>
<br>
</div>

<h3 class="section">6.13 Writing Data Values: NF90_PUT_VAR</h3>

<p><a name="index-NF90_005fPUT_005fVAR-138"></a><a name="index-NF90_005fPUT_005fVAR_002c-example-139"></a>
The function NF90_PUT_VAR puts one or more data values into the
variable of an open netCDF dataset that is in data mode. Required
inputs are the netCDF ID, the variable ID, and one or more data
values. Optional inputs may indicate the starting position of the data
values in the netCDF variable (argument start), the sampling frequency
with which data values are written into the netCDF variable (argument
stride), and a mapping between the dimensions of the data array and
the netCDF variable (argument map). The values to be written are
associated with the netCDF variable by assuming that the first
dimension of the netCDF variable varies fastest in the Fortran 90
interface. Data values converted to the external type of the variable,
if necessary.

   <p>Take care when using the simplest forms of this interface with record
variables when you don't specify how many records are to be
written. If you try to write all the values of a record variable into
a netCDF file that has no record data yet (hence has 0 records),
nothing will be written. Similarly, if you try to write all of a
record variable but there are more records in the file than you
assume, more data may be written to the file than you supply, which
may result in a segmentation violation.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_put_var(ncid, varid, values, start, count, stride, map)
        integer,                         intent( in) :: ncid, varid
        any valid type, scalar or array of any rank, &amp;
                                         intent( in) :: values
        integer, dimension(:), optional, intent( in) :: start, count, stride, map
        integer                                      :: nf90_put_var
</pre>
     <dl>
<dt><code>ncid</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>varid</code><dd>Variable ID.

     <br><dt><code>values</code><dd>The data value(s) to be written. The data may be of any type, and may
be a scalar or an array of any rank.  You cannot put CHARACTER data
into a numeric variable or numeric data into a text variable. For
numeric data, if the type of data differs from the netCDF variable
type, type conversion will occur. See <a href="netcdf.html#Type-Conversion">Type Conversion (NetCDF Users Guide)</a>.

     <br><dt><code>start</code><dd>A vector of integers specifying the index in the variable where the
first (or only) of the data values will be written. The indices are
relative to 1, so for example, the first data value of a variable
would have index (1, 1, ..., 1). The elements of start correspond, in
order, to the variable's dimensions. Hence, if the variable is a
record variable, the last index would correspond to the starting
record number for writing the data values.

     <p>By default, start(:) = 1.

     <br><dt><code>count</code><dd>A vector of integers specifying the number of indices selected along
each dimension. To write a single value, for example, specify count as
(1, 1, ..., 1). The elements of count correspond, in order, to the
variable's dimensions. Hence, if the variable is a record variable,
the last element of count corresponds to a count of the number of
records to write.

     <p>By default, count(:numDims) = shape(values) and
count(numDims + 1:) = 1, where numDims = size(shape(values)).

     <br><dt><code>stride</code><dd>A vector of integers that specifies the sampling interval along each
dimension of the netCDF variable. The elements of the stride vector
correspond, in order, to the netCDF variable's dimensions (stride(1)
gives the sampling interval along the most rapidly varying dimension
of the netCDF variable). Sampling intervals are specified in
type-independent units of elements (a value of 1 selects consecutive
elements of the netCDF variable along the corresponding dimension, a
value of 2 selects every other element, etc.).

     <p>By default, stride(:) = 1.

     <br><dt><code>imap</code><dd>A vector of integers that specifies the mapping between the dimensions
of a netCDF variable and the in-memory structure of the internal data
array. The elements of the index mapping vector correspond, in order,
to the netCDF variable's dimensions (map(1) gives the distance between
elements of the internal array corresponding to the most rapidly
varying dimension of the netCDF variable). Distances between elements
are specified in units of elements.

     <p>By default, edgeLengths = shape(values), and
map = (/ 1, (product(edgeLengths(:i)), i = 1, size(edgeLengths) - 1) /),
that is, there is no mapping.

     <p>Use of Fortran 90 intrinsic functions (including reshape, transpose,
and spread) may let you avoid using this argument. 
</dl>

<h3 class="heading">Errors</h3>

<p>NF90_PUT_VAR1_  type returns the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:

     <ul>
<li>The variable ID is invalid for the specified netCDF dataset.

     <li>The specified indices were out of range for the rank of the specified
variable. For example, a negative index or an index that is larger
than the corresponding dimension length will cause an error.

     <li>The specified value is out of the range of values representable by the
external data type of the variable.

     <li>The specified netCDF is in define mode rather than data mode.

     <li>The specified netCDF ID does not refer to an open netCDF dataset. 
</ul>

<h3 class="heading">Example</h3>

<p>Here is an example using NF90_PUT_VAR to set the (4,3,2) element of
the variable named rh to 0.5 in an existing netCDF dataset named
foo.nc. For simplicity in this example, we assume that we know that rh
is dimensioned with lon, lat, and time, so we want to set the value of
rh that corresponds to the fourth lon value, the third lat value, and
the second time value:

<pre class="example">      use netcdf
      implicit none
      integer :: ncId, rhVarId, status
      ...
      status = nf90_open("foo.nc", nf90_Write, ncid)
      if(status /= nf90_NoErr) call handle_err(status)
      ...
      status = nf90_inq_varid(ncid, "rh", rhVarId)
      if(status /= nf90_NoErr) call handle_err(status)
      status = nf90_put_var(ncid, rhVarId, 0.5, start = (/ 4, 3, 2 /) )
      if(status /= nf90_NoErr) call handle_err(status)
</pre>
   <p>In this example we use NF90_PUT_VAR to add or change all the values of
the variable named rh to 0.5 in an existing netCDF dataset named
foo.nc. We assume that we know that rh is dimensioned with lon, lat,
and time. In this example we query the netCDF file to discover the
lengths of the dimensions, then use the Fortran 90 intrinsic function
reshape to create a temporary array of data values which is the same
shape as the netCDF variable.

<pre class="example">      use netcdf
      implicit none
      integer                               :: ncId, rhVarId,status,          &amp;
                                               lonDimID, latDimId, timeDimId, &amp;
                                               numLons, numLats, numTimes,    &amp;
                                               i
      integer, dimension(nf90_max_var_dims) :: dimIDs
      ...
      status = nf90_open("foo.nc", nf90_Write, ncid)
      if(status /= nf90_NoErr) call handle_err(status)
      ...
      status = nf90_inq_varid(ncid, "rh", rhVarId)
      if(status /= nf90_NoErr) call handle_err(status)
      ! How big is the netCDF variable, that is, what are the lengths of
      !   its constituent dimensions?
      status = nf90_inquire_variable(ncid, rhVarId, dimids = dimIDs)
      if(status /= nf90_NoErr) call handle_err(status)
      status = nf90_inquire_dimension(ncid, dimIDs(1), len = numLons)
      if(status /= nf90_NoErr) call handle_err(status)
      status = nf90_inquire_dimension(ncid, dimIDs(2), len = numLats)
      if(status /= nf90_NoErr) call handle_err(status)
      status = nf90_inquire_dimension(ncid, dimIDs(3), len = numTimes)
      if(status /= nf90_NoErr) call handle_err(status)
      ...
      ! Make a temporary array the same shape as the netCDF variable.
      status = nf90_put_var(ncid, rhVarId, &amp;
                            reshape( &amp;
                              (/ (0.5, i = 1, numLons * numLats * numTimes) /) , &amp;
                             shape = (/ numLons, numLats, numTimes /) )
      if(status /= nf90_NoErr) call handle_err(status)
</pre>
   <p>Here is an example using NF90_PUT_VAR to add or change a section of
the variable named rh to 0.5 in an existing netCDF dataset named
foo.nc. For simplicity in this example, we assume that we know that rh
is dimensioned with lon, lat, and time, that there are ten lon values,
five lat values, and three time values, and that we want to replace
all the values at the last time.

<pre class="example">      use netcdf
      implicit none
      integer            :: ncId, rhVarId, status
      integer, parameter :: numLons = 10, numLats = 5, numTimes = 3
      real, dimension(numLons, numLats) &amp;
                         :: rhValues
      ...
      status = nf90_open("foo.nc", nf90_Write, ncid)
      if(status /= nf90_NoErr) call handle_err(status)
      ...
      status = nf90_inq_varid(ncid, "rh", rhVarId)
      if(status /= nf90_NoErr) call handle_err(status)
      ! Fill in all values at the last time
      rhValues(:, :) = 0.5
      status = nf90_put_var(ncid, rhVarId,rhvalues,       &amp;
                            start = (/ 1, 1, numTimes /), &amp;
                            count = (/ numLats, numLons, 1 /))
      if(status /= nf90_NoErr) call handle_err(status)
</pre>
   <p>Here is an example of using NF_PUT_VAR to write every other point of a
netCDF variable named rh having dimensions (6, 4).

<pre class="example">      use netcdf
      implicit none
      integer            :: ncId, rhVarId, status
      integer, parameter :: numLons = 6, numLats = 4
      real, dimension(numLons, numLats) &amp;
                         :: rhValues = 0.5
      ...
      status = nf90_open("foo.nc", nf90_Write, ncid)
      if(status /= nf90_NoErr) call handle_err(status)
      ...
      status = nf90_inq_varid(ncid, "rh", rhVarId)
      if(status /= nf90_NoErr) call handle_err(status)
      ...
      ! Fill in every other value using an array section
      status = nf90_put_var(ncid, rhVarId, rhValues(::2, ::2), &amp;
                            stride = (/ 2, 2 /))
      if(status /= nf90_NoErr) call handle_err(status)
</pre>
   <p>The following map vector shows the default mapping between a 2x3x4
netCDF variable and an internal array of the same shape:

<pre class="example">      real,    dimension(2, 3, 4):: a  ! same shape as netCDF variable
      integer, dimension(3)      :: map  = (/ 1, 2, 6 /)
                          ! netCDF dimension inter-element distance
                          ! ---------------- ----------------------
                          ! most rapidly varying       1
                          ! intermediate               2 (= map(1)*2)
                          ! most slowly varying        6 (= map(2)*3)
</pre>
   <p>Using the map vector above obtains the same result as simply not passing a map vector at all.

   <p>Here is an example of using nf90_put_var to write a netCDF variable
named rh whose dimensions are the transpose of the Fortran 90 array:

<pre class="example">      use netcdf
      implicit none
      integer                           :: ncId, rhVarId, status
      integer, parameter                :: numLons = 6, numLats = 4
      real, dimension(numLons, numLats) :: rhValues
      ! netCDF variable has dimensions (numLats, numLons)
      ...
      status = nf90_open("foo.nc", nf90_Write, ncid)
      if(status /= nf90_NoErr) call handle_err(status)
      ...
      status = nf90_inq_varid(ncid, "rh", rhVarId)
      if(status /= nf90_NoErr) call handle_err(status)
      ...
      !Write transposed values: map vector would be (/ 1, numLats /) for
      !   no transposition
      status = nf90_put_var(ncid, rhVarId,rhValues, map = (/ numLons, 1 /))
      if(status /= nf90_NoErr) call handle_err(status)
</pre>
   <p>The same effect can be obtained more simply using Fortran 90 intrinsic functions:

<pre class="example">      use netcdf
      implicit none
      integer                           :: ncId, rhVarId, status
      integer, parameter                :: numLons = 6, numLats = 4
      real, dimension(numLons, numLats) :: rhValues
      ! netCDF variable has dimensions (numLats, numLons)
      ...
      status = nf90_open("foo.nc", nf90_Write, ncid)
      if(status /= nf90_NoErr) call handle_err(status)
      ...
      status = nf90_inq_varid(ncid, "rh", rhVarId)
      if(status /= nf90_NoErr) call handle_err(status)
      ...
      status = nf90_put_var(ncid, rhVarId, transpose(rhValues))
      if(status /= nf90_NoErr) call handle_err(status)
</pre>
   <div class="node">
<p><hr>
<a name="NF90_005fGET_005fVAR"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Reading-and-Writing-Character-String-Values">Reading and Writing Character String Values</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fPUT_005fVAR">NF90_PUT_VAR</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variables">Variables</a>
<br>
</div>

<h3 class="section">6.14 Reading Data Values: NF90_GET_VAR</h3>

<p><a name="index-NF90_005fGET_005fVAR-140"></a><a name="index-NF90_005fGET_005fVAR_002c-example-141"></a>
The function NF90_GET_VAR gets one or more data values from a netCDF
variable of an open netCDF dataset that is in data mode. Required
inputs are the netCDF ID, the variable ID, and a specification for the
data values into which the data will be read. Optional inputs may
indicate the starting position of the data values in the netCDF
variable (argument start), the sampling frequency with which data
values are read from the netCDF variable (argument stride), and a
mapping between the dimensions of the data array and the netCDF
variable (argument map). The values to be read are associated with the
netCDF variable by assuming that the first dimension of the netCDF
variable varies fastest in the Fortran 90 interface. Data values are
converted from the external type of the variable, if necessary.

   <p>Take care when using the simplest forms of this interface with record
variables when you don't specify how many records are to be read. If
you try to read all the values of a record variable into an array but
there are more records in the file than you assume, more data will be
read than you expect, which may cause a segmentation violation.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_get_var(ncid, varid, values, start, count, stride, map)
        integer,                         intent( in) :: ncid, varid
        any valid type, scalar or array of any rank, &amp;
                                         intent(out) :: values
        integer, dimension(:), optional, intent( in) :: start, count, stride, map
        integer                                      :: nf90_get_var
</pre>
     <dl>
<dt><code>ncid</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>varid</code><dd>Variable ID.

     <br><dt><code>values</code><dd>The data value(s) to be read. The data may be of any type, and may be
a scalar or an array of any rank.  You cannot read CHARACTER data from
a numeric variable or numeric data from a text variable. For numeric
data, if the type of data differs from the netCDF variable type, type
conversion will occur. See <a href="netcdf.html#Type-Conversion">Type Conversion (NetCDF Users Guide)</a>.

     <br><dt><code>start</code><dd>A vector of integers specifying the index in the variable from which
the first (or only) of the data values will be read. The indices are
relative to 1, so for example, the first data value of a variable
would have index (1, 1, ..., 1). The elements of start correspond, in
order, to the variable's dimensions. Hence, if the variable is a
record variable, the last index would correspond to the starting
record number for writing the data values.

     <p>By default, start(:) = 1.

     <br><dt><code>count</code><dd>A vector of integers specifying the number of indices selected along
each dimension. To read a single value, for example, specify count as
(1, 1, ..., 1). The elements of count correspond, in order, to the
variable's dimensions. Hence, if the variable is a record variable,
the last element of count corresponds to a count of the number of
records to read.

     <p>By default, count(:numDims) = shape(values) and
count(numDims + 1:) = 1, where numDims = size(shape(values)).

     <br><dt><code>stride</code><dd>A vector of integers that specifies the sampling interval along each
dimension of the netCDF variable. The elements of the stride vector
correspond, in order, to the netCDF variable's dimensions (stride(1)
gives the sampling interval along the most rapidly varying dimension
of the netCDF variable). Sampling intervals are specified in
type-independent units of elements (a value of 1 selects consecutive
elements of the netCDF variable along the corresponding dimension, a
value of 2 selects every other element, etc.).

     <p>By default, stride(:) = 1.

     <br><dt><code>map</code><dd>A vector of integers that specifies the mapping between the dimensions
of a netCDF variable and the in-memory structure of the internal data
array. The elements of the index mapping vector correspond, in order,
to the netCDF variable's dimensions (map(1) gives the distance between
elements of the internal array corresponding to the most rapidly
varying dimension of the netCDF variable). Distances between elements
are specified in units of elements.

     <p>By default, edgeLengths = shape(values), and
map = (/ 1, (product(edgeLengths(:i)), i = 1, size(edgeLengths) - 1) /),
that is, there is no mapping.

     <p>Use of Fortran 90 intrinsic functions (including reshape, transpose,
and spread) may let you avoid using this argument.

   </dl>

<h3 class="heading">Errors</h3>

<p>NF90_GET_VAR returns the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:

     <ul>
<li>The variable ID is invalid for the specified netCDF dataset.

     <li>The assumed or specified start, count, and stride generate an index
which is out of range. Note that no error checking is possible on the
map vector.

     <li>One or more of the specified values are out of the range of values
representable by the desired type.

     <li>The specified netCDF is in define mode rather than data mode.

     <li>The specified netCDF ID does not refer to an open netCDF dataset. 
</ul>

   <p>(As noted above, another possible source of error is using this
interface to read all the values of a record variable without
specifying the number of records. If there are more records in the
file than you assume, more data will be read than you expect!)

<h3 class="heading">Example</h3>

<p>Here is an example using NF90_GET_VAR to read the (4,3,2) element of
the variable named rh from an existing netCDF dataset named
foo.nc. For simplicity in this example, we assume that we know that rh
is dimensioned with lon, lat, and time, so we want to read the value
of rh that corresponds to the fourth lon value, the third lat value,
and the second time value:

<pre class="example">      use netcdf
      implicit none
      integer :: ncId, rhVarId, status
      real    :: rhValue
      ...
      status = nf90_open("foo.nc", nf90_NoWrite, ncid)
      if(status /= nf90_NoErr) call handle_err(status)
      -
      status = nf90_inq_varid(ncid, "rh", rhVarId)
      if(status /= nf90_NoErr) call handle_err(status)
      status = nf90_get_var(ncid, rhVarId, rhValue, start = (/ 4, 3, 2 /) )
      if(status /= nf90_NoErr) call handle_err(status)
</pre>
   <p>In this example we use NF90_GET_VAR to read all the values of the
variable named rh from an existing netCDF dataset named foo.nc. We
assume that we know that rh is dimensioned with lon, lat, and time. In
this example we query the netCDF file to discover the lengths of the
dimensions, then allocate a Fortran 90 array the same shape as the
netCDF variable.

<pre class="example">      use netcdf
      implicit none
      integer                               :: ncId, rhVarId, &amp;
                                               lonDimID, latDimId, timeDimId, &amp;
                                               numLons, numLats, numTimes,    &amp;
                                               status
      integer, dimension(nf90_max_var_dims) :: dimIDs
      real, dimension(:, :, :), allocatable :: rhValues
      ...
      status = nf90_open("foo.nc", nf90_NoWrite, ncid)
      if(status /= nf90_NoErr) call handle_err(status)
      ...
      status = nf90_inq_varid(ncid, "rh", rhVarId)
      if(status /= nf90_NoErr) call handle_err(status)
      ! How big is the netCDF variable, that is, what are the lengths of
      !   its constituent dimensions?
      status = nf90_inquire_variable(ncid, rhVarId, dimids = dimIDs)
      if(status /= nf90_NoErr) call handle_err(status)
      status = nf90_inquire_dimension(ncid, dimIDs(1), len = numLons)
      if(status /= nf90_NoErr) call handle_err(status)
      status = nf90_inquire_dimension(ncid, dimIDs(2), len = numLats)
      if(status /= nf90_NoErr) call handle_err(status)
      status = nf90_inquire_dimension(ncid, dimIDs(3), len = numTimes)
      if(status /= nf90_NoErr) call handle_err(status)
      allocate(rhValues(numLons, numLats, numTimes))
      ...
      status = nf90_get_var(ncid, rhVarId, rhValues)
      if(status /= nf90_NoErr) call handle_err(status)
</pre>
   <p>Here is an example using NF90_GET_VAR to read a section of the
variable named rh from an existing netCDF dataset named foo.nc. For
simplicity in this example, we assume that we know that rh is
dimensioned with lon, lat, and time, that there are ten lon values,
five lat values, and three time values, and that we want to replace
all the values at the last time.

<pre class="example">      use netcdf
      implicit none
      integer            :: ncId, rhVarId, status
      integer, parameter :: numLons = 10, numLats = 5, numTimes = 3
      real, dimension(numLons, numLats, numTimes) &amp;
                         :: rhValues
      ...
      status = nf90_open("foo.nc", nf90_NoWrite, ncid)
      if(status /= nf90_NoErr) call handle_err(status)
      ...
      status = nf90_inq_varid(ncid, "rh", rhVarId)
      if(status /= nf90_NoErr) call handle_err(status)
      !Read the values at the last time by passing an array section
      status = nf90_get_var(ncid, rhVarId, rhValues(:, :, 3), &amp;
                            start = (/ 1, 1, numTimes /),     &amp;
                            count = (/ numLats, numLons, 1 /))
      if(status /= nf90_NoErr) call handle_err(status)
</pre>
   <p>Here is an example of using NF_GET_VAR to read every other point of a
netCDF variable named rh having dimensions (6, 4).

<pre class="example">      use netcdf
      implicit none
      integer            :: ncId, rhVarId, status
      integer, parameter :: numLons = 6, numLats = 4
      real, dimension(numLons, numLats) &amp;
                         :: rhValues
      ...
      status = nf90_open("foo.nc", nf90_NoWrite, ncid)
      if(status /= nf90_NoErr) call handle_err(status)
      ...
      status = nf90_inq_varid(ncid, "rh", rhVarId)
      if(status /= nf90_NoErr) call handle_err(status)
      ...
      ! Read every other value into an array section
      status = nf90_get_var(ncid, rhVarId, rhValues(::2, ::2) &amp;
                            stride = (/ 2, 2 /))
      if(status /= nf90_NoErr) call handle_err(status)
</pre>
   <p>The following map vector shows the default mapping between a 2x3x4
netCDF variable and an internal array of the same shape:

<pre class="example">      real,    dimension(2, 3, 4):: a  ! same shape as netCDF variable
      integer, dimension(3)      :: map  = (/ 1, 2, 6 /)
                          ! netCDF dimension inter-element distance
                          ! ---------------- ----------------------
                          ! most rapidly varying       1
                          ! intermediate               2 (= map(1)*2)
                          ! most slowly varying        6 (= map(2)*3)
</pre>
   <p>Using the map vector above obtains the same result as simply not
passing a map vector at all.

   <p>Here is an example of using nf90_get_var to read a netCDF variable
named rh whose dimensions are the transpose of the Fortran 90 array:

<pre class="example">      use netcdf
      implicit none
      integer                           :: ncId, rhVarId, status
      integer, parameter                :: numLons = 6, numLats = 4
      real, dimension(numLons, numLats) :: rhValues
      ! netCDF variable has dimensions (numLats, numLons)
      ...
      status = nf90_open("foo.nc", nf90_NoWrite, ncid)
      if(status /= nf90_NoErr) call handle_err(status)
      ...
      status = nf90_inq_varid(ncid, "rh", rhVarId)
      if(status /= nf90_NoErr) call handle_err(status)
      ...
      ! Read transposed values: map vector would be (/ 1, numLats /) for
      !   no transposition
      status = nf90_get_var(ncid, rhVarId,rhValues, map = (/ numLons, 1 /))
      if(status /= nf90_NoErr) call handle_err(status)
</pre>
   <p>The same effect can be obtained more simply, though using more memory,
using Fortran 90 intrinsic functions:

<pre class="example">      use netcdf
      implicit none
      integer                           :: ncId, rhVarId, status
      integer, parameter                :: numLons = 6, numLats = 4
      real, dimension(numLons, numLats) :: rhValues
      ! netCDF variable has dimensions (numLats, numLons)
      real, dimension(numLons, numLats) :: tempValues
      ...
      status = nf90_open("foo.nc", nf90_NoWrite, ncid)
      if(status /= nf90_NoErr) call handle_err(status)
      ...
      status = nf90_inq_varid(ncid, "rh", rhVarId)
      if(status /= nf90_NoErr) call handle_err(status)
      ...
      status = nf90_get_var(ncid, rhVarId, tempValues))
      if(status /= nf90_NoErr) call handle_err(status)
      rhValues(:, :) = transpose(tempValues)
</pre>
   <div class="node">
<p><hr>
<a name="Reading-and-Writing-Character-String-Values"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Fill-Values">Fill Values</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fGET_005fVAR">NF90_GET_VAR</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variables">Variables</a>
<br>
</div>

<h3 class="section">6.15 Reading and Writing Character String Values</h3>

<p>Character strings are not a primitive netCDF external data type, in
part because FORTRAN does not support the abstraction of
variable-length character strings (the FORTRAN LEN function returns
the static length of a character string, not its dynamic length). As a
result, a character string cannot be written or read as a single
object in the netCDF interface. Instead, a character string must be
treated as an array of characters, and array access must be used to
read and write character strings as variable data in netCDF
datasets. Furthermore, variable-length strings are not supported by
the netCDF interface except by convention; for example, you may treat
a zero byte as terminating a character string, but you must explicitly
specify the length of strings to be read from and written to netCDF
variables.

   <p>Character strings as attribute values are easier to use, since the
strings are treated as a single unit for access. However, the value of
a character-string attribute is still an array of characters with an
explicit length that must be specified when the attribute is defined.

   <p>When you define a variable that will have character-string values, use
a character-position dimension as the most quickly varying dimension
for the variable (the first dimension for the variable in Fortran
90). The length of the character-position dimension will be the
maximum string length of any value to be stored in the
character-string variable. Space for maximum-length strings will be
allocated in the disk representation of character-string variables
whether you use the space or not. If two or more variables have the
same maximum length, the same character-position dimension may be used
in defining the variable shapes.

   <p>To write a character-string value into a character-string variable,
use either entire variable access or array access. The latter requires
that you specify both a corner and a vector of edge lengths. The
character-position dimension at the corner should be one for Fortran
90. If the length of the string to be written is n, then the vector of
edge lengths will specify n in the character-position dimension, and
one for all the other dimensions: (n, 1, 1, ..., 1).

   <p>In Fortran 90, fixed-length strings may be written to a netCDF dataset
without a terminating character, to save space. Variable-length
strings should follow the C convention of writing strings with a
terminating zero byte so that the intended length of the string can be
determined when it is later read by either C or Fortran 90 programs.

<div class="node">
<p><hr>
<a name="Fill-Values"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fRENAME_005fVAR">NF90_RENAME_VAR</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Reading-and-Writing-Character-String-Values">Reading and Writing Character String Values</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variables">Variables</a>
<br>
</div>

<h3 class="section">6.16 Fill Values</h3>

<p>What happens when you try to read a value that was never written in an
open netCDF dataset? You might expect that this should always be an
error, and that you should get an error message or an error status
returned. You do get an error if you try to read data from a netCDF
dataset that is not open for reading, if the variable ID is invalid
for the specified netCDF dataset, or if the specified indices are not
properly within the range defined by the dimension lengths of the
specified variable. Otherwise, reading a value that was not written
returns a special fill value used to fill in any undefined values when
a netCDF variable is first written.

   <p>You may ignore fill values and use the entire range of a netCDF
external data type, but in this case you should make sure you write
all data values before reading them. If you know you will be writing
all the data before reading it, you can specify that no prefilling of
variables with fill values will occur by calling writing. This may
provide a significant performance gain for netCDF writes.

   <p>The variable attribute _FillValue may be used to specify the fill
value for a variable. There are default fill values for each type,
defined in module netcdf: NF90_FILL_CHAR, NF90_FILL_INT1 (same as
NF90_FILL_BYTE), NF90_FILL_INT2 (same as NF90_FILL_SHORT),
NF90_FILL_INT, NF90_FILL_REAL (same as NF90_FILL_FLOAT), and
NF90_FILL_DOUBLE

   <p>The netCDF byte and character types have different default fill
values. The default fill value for characters is the zero byte, a
useful value for detecting the end of variable-length C character
strings. If you need a fill value for a byte variable, it is
recommended that you explicitly define an appropriate _FillValue
attribute, as generic utilities such as ncdump will not assume a
default fill value for byte variables.

   <p>Type conversion for fill values is identical to type conversion for
other values: attempting to convert a value from one type to another
type that can't represent the value results in a range error. Such
errors may occur on writing or reading values from a larger type (such
as double) to a smaller type (such as float), if the fill value for
the larger type cannot be represented in the smaller type.

<div class="node">
<p><hr>
<a name="NF90_005fRENAME_005fVAR"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#Fill-Values">Fill Values</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variables">Variables</a>
<br>
</div>

<h3 class="section">6.17 NF90_RENAME_VAR</h3>

<p><a name="index-NF90_005fRENAME_005fVAR-142"></a><a name="index-NF90_005fRENAME_005fVAR-_002c-example-143"></a>
The function NF90_RENAME_VAR changes the name of a netCDF variable in an
open netCDF dataset. If the new name is longer than the old name, the
netCDF dataset must be in define mode. You cannot rename a variable to
have the name of any existing variable.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_rename_var(ncid, varid, newname)
        integer,             intent( in) :: ncid, varid
        character (len = *), intent( in) :: newname
        integer                          :: nf90_rename_var
</pre>
     <dl>
<dt><code>ncid</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>varid</code><dd>Variable ID.

     <br><dt><code>newname</code><dd>New name for the specified variable. 
</dl>

<h3 class="heading">Errors</h3>

<p>NF90_RENAME_VAR returns the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:

     <ul>
<li>The new name is in use as the name of another variable.

     <li>The variable ID is invalid for the specified netCDF dataset.

     <li>The specified netCDF ID does not refer to an open netCDF dataset. 
</ul>

<h3 class="heading">Example</h3>

<p>Here is an example using NF90_RENAME_VAR to rename the variable rh to
rel_hum in an existing netCDF dataset named foo.nc:

<pre class="example">      use netcdf
      implicit none
      integer :: ncId, rhVarId, status
      ...
      status = nf90_open("foo.nc", nf90_Write, ncid)
      if(status /= nf90_NoErr) call handle_err(status)
      ...
      status = nf90_inq_varid(ncid, "rh", rhVarId)
      if(status /= nf90_NoErr) call handle_err(status)
      status = nf90_redef(ncid)  ! Enter define mode to change variable name
      if(status /= nf90_NoErr) call handle_err(status)
      status = nf90_rename_var(ncid, rhVarId, "rel_hum")
      if(status /= nf90_NoErr) call handle_err(status)
      status = nf90_enddef(ncid) ! Leave define mode
      if(status /= nf90_NoErr) call handle_err(status)
</pre>
   <div class="node">
<p><hr>
<a name="Attributes"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Summary-of-Fortran-90-Interface">Summary of Fortran 90 Interface</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Variables">Variables</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="chapter">7 Attributes</h2>

<ul class="menu">
<li><a accesskey="1" href="#Attributes-Introduction">Attributes Introduction</a>
<li><a accesskey="2" href="#Attribute-Conventions">Attribute Conventions</a>
<li><a accesskey="3" href="#NF90_005fPUT_005fATT">NF90_PUT_ATT</a>
<li><a accesskey="4" href="#NF90_005fINQUIRE_005fATTRIBUTE">NF90_INQUIRE_ATTRIBUTE</a>
<li><a accesskey="5" href="#NF90_005fGET_005fATT">NF90_GET_ATT</a>
<li><a accesskey="6" href="#NF90_005fCOPY_005fATT">NF90_COPY_ATT</a>
<li><a accesskey="7" href="#NF90_005fRENAME_005fATT">NF90_RENAME_ATT</a>
<li><a accesskey="8" href="#NF90_005fDEL_005fATT">NF90_DEL_ATT</a>
</ul>

<div class="node">
<p><hr>
<a name="Attributes-Introduction"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Attribute-Conventions">Attribute Conventions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Attributes">Attributes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Attributes">Attributes</a>
<br>
</div>

<h3 class="section">7.1 Attributes Introduction</h3>

<p>Attributes may be associated with each netCDF variable to specify such
properties as units, special values, maximum and minimum valid values,
scaling factors, and offsets. Attributes for a netCDF dataset are
defined when the dataset is first created, while the netCDF dataset is
in define mode. Additional attributes may be added later by reentering
define mode. A netCDF attribute has a netCDF variable to which it is
assigned, a name, a type, a length, and a sequence of one or more
values. An attribute is designated by its variable ID and name. When
an attribute name is not known, it may be designated by its variable
ID and number in order to determine its name, using the function
NF90_INQ_ATTNAME.

   <p>The attributes associated with a variable are typically defined
immediately after the variable is created, while still in define
mode. The data type, length, and value of an attribute may be changed
even when in data mode, as long as the changed attribute requires no
more space than the attribute as originally defined.

   <p>It is also possible to have attributes that are not associated with
any variable. These are called global attributes and are identified by
using NF90_GLOBAL as a variable pseudo-ID. Global attributes are
usually related to the netCDF dataset as a whole and may be used for
purposes such as providing a title or processing history for a netCDF
dataset.

   <p>Operations supported on attributes are:

     <ul>
<li>Create an attribute, given its variable ID, name, data type, length, and value.

     <li>Get attribute's data type and length from its variable ID and name.

     <li>Get attribute's value from its variable ID and name.

     <li>Copy attribute from one netCDF variable to another.

     <li>Get name of attribute from its number.

     <li>Rename an attribute.

     <li>Delete an attribute. 
</ul>

<div class="node">
<p><hr>
<a name="Attribute-Conventions"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fPUT_005fATT">NF90_PUT_ATT</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Attributes-Introduction">Attributes Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Attributes">Attributes</a>
<br>
</div>

<h3 class="section">7.2 Attribute Conventions</h3>

<p>Names commencing with underscore ('_') are reserved for use by the
netCDF library. Most generic applications that process netCDF datasets
assume standard attribute conventions and it is strongly recommended
that these be followed unless there are good reasons for not doing
so. Below we list the names and meanings of recommended standard
attributes that have proven useful. Note that some of these
(e.g. units, valid_range, scale_factor) assume numeric data and should
not be used with character data. 
units

   <p>A character string that specifies the units used for the variable's
data. Unidata has developed a freely-available library of routines to
convert between character string and binary forms of unit
specifications and to perform various useful operations on the binary
forms. This library is used in some netCDF applications. Using the
recommended units syntax permits data represented in conformable units
to be automatically converted to common units for arithmetic
operations. See <a href="netcdf.html#Appendix-A-_002d-Units">Appendix A - Units (NetCDF Users Guide)</a>.

     <dl>
<dt><code>long_name</code><dd>A long descriptive name. This could be used for labeling plots, for
example. If a variable has no long_name attribute assigned, the
variable name should be used as a default.

     <br><dt><code>valid_min</code><dd>A scalar specifying the minimum valid value for this variable.

     <br><dt><code>valid_max</code><dd> A scalar specifying the maximum valid value for this variable.

     <br><dt><code>valid_range</code><dd>
A vector of two numbers specifying the minimum and maximum valid
values for this variable, equivalent to specifying values for both
valid_min and valid_max attributes. Any of these attributes define the
valid range. The attribute valid_range must not be defined if either
valid_min or valid_max is defined.

     <p>Generic applications should treat values outside the valid range as
missing. The type of each valid_range, valid_min and valid_max
attribute should match the type of its variable (except that for byte
data, these can be of a signed integral type to specify the intended
range).

     <p>If neither valid_min, valid_max nor valid_range is defined then
generic applications should define a valid range as follows. If the
data type is byte and _FillValue is not explicitly defined, then the
valid range should include all possible values. Otherwise, the valid
range should exclude the _FillValue (whether defined explicitly or by
default) as follows. If the _FillValue is positive then it defines a
valid maximum, otherwise it defines a valid minimum. For integer
types, there should be a difference of 1 between the _FillValue and
this valid minimum or maximum. For floating point types, the
difference should be twice the minimum possible (1 in the least
significant bit) to allow for rounding error.

     <br><dt><code>scale_factor</code><dd>
If present for a variable, the data are to be multiplied by this
factor after the data are read by the application that accesses the
data.

     <br><dt><code>add_offset</code><dd>
If present for a variable, this number is to be added to the data
after it is read by the application that accesses the data. If both
scale_factor and add_offset attributes are present, the data are first
scaled before the offset is added. The attributes scale_factor and
add_offset can be used together to provide simple data compression to
store low-resolution floating-point data as small integers in a netCDF
dataset. When scaled data are written, the application should first
subtract the offset and then divide by the scale factor.

     <p>When scale_factor and add_offset are used for packing, the associated
variable (containing the packed data) is typically of type byte or
short, whereas the unpacked values are intended to be of type float or
double. The attributes scale_factor and add_offset should both be of
the type intended for the unpacked data, e.g. float or double.

     <br><dt><code>_FillValue</code><dd>The _FillValue attribute specifies the fill value used to pre-fill
disk space allocated to the variable. Such pre-fill occurs unless
nofill mode is set using NF90_SET_FILL. See <a href="#NF90_005fSET_005fFILL">NF90_SET_FILL</a>. The fill
value is returned when reading values that were never written. If
_FillValue is defined then it should be scalar and of the same type as
the variable. It is not necessary to define your own _FillValue
attribute for a variable if the default fill value for the type of the
variable is adequate. However, use of the default fill value for data
type byte is not recommended. Note that if you change the value of
this attribute, the changed value applies only to subsequent writes;
previously written data are not changed.

     <p>Generic applications often need to write a value to represent
undefined or missing values. The fill value provides an appropriate
value for this purpose because it is normally outside the valid range
and therefore treated as missing when read by generic applications. It
is legal (but not recommended) for the fill value to be within the
valid range.

     <p>See <a href="#Fill-Values">Fill Values</a>.

     <br><dt><code>missing_value</code><dd>This attribute is not treated in any special way by the
library or conforming generic applications, but is often useful
documentation and may be used by specific applications. The
missing_value attribute can be a scalar or vector containing values
indicating missing data. These values should all be outside the valid
range so that generic applications will treat them as missing.

     <br><dt><code>signedness</code><dd>Deprecated attribute, originally designed to indicate whether byte
values should be treated as signed or unsigned. The attributes
valid_min and valid_max may be used for this purpose. For example, if
you intend that a byte variable store only nonnegative values, you can
use valid_min = 0 and valid_max = 255. This attribute is ignored by
the netCDF library.

     <br><dt><code>C_format</code><dd>A character array providing the format that should be used by C
applications to print values for this variable. For example, if you
know a variable is only accurate to three significant digits, it would
be appropriate to define the C_format attribute as "%.3g". The ncdump
utility program uses this attribute for variables for which it is
defined. The format applies to the scaled (internal) type and value,
regardless of the presence of the scaling attributes scale_factor and
add_offset.

     <br><dt><code>FORTRAN_format</code><dd>A character array providing the format that should be used by FORTRAN
applications to print values for this variable. For example, if you
know a variable is only accurate to three significant digits, it would
be appropriate to define the FORTRAN_format attribute as "(G10.3)".

     <br><dt><code>title</code><dd>A global attribute that is a character array providing a succinct
description of what is in the dataset.

     <br><dt><code>history</code><dd>A global attribute for an audit trail. This is a character array with
a line for each invocation of a program that has modified the
dataset. Well-behaved generic netCDF applications should append a line
containing: date, time of day, user name, program name and command
arguments.

     <br><dt><code>Conventions</code><dd>If present, 'Conventions' is a global attribute that is a character
array for the name of the conventions followed by the dataset, in the
form of a string that is interpreted as a directory name relative to a
directory that is a repository of documents describing sets of
discipline-specific conventions. This permits a hierarchical structure
for conventions and provides a place where descriptions and examples
of the conventions may be maintained by the defining institutions and
groups. The conventions directory name is currently interpreted
relative to the directory pub/netcdf/Conventions/ on the host machine
ftp.unidata.ucar.edu. Alternatively, a full URL specification may be
used to name a WWW site where documents that describe the conventions
are maintained.

     <p>For example, if a group named NUWG agrees upon a set of conventions
for dimension names, variable names, required attributes, and netCDF
representations for certain discipline-specific data structures, they
may store a document describing the agreed-upon conventions in a
dataset in the NUWG/ subdirectory of the Conventions
directory. Datasets that followed these conventions would contain a
global Conventions attribute with value "NUWG".

     <p>Later, if the group agrees upon some additional conventions for a
specific subset of NUWG data, for example time series data, the
description of the additional conventions might be stored in the
NUWG/Time_series/ subdirectory, and datasets that adhered to these
additional conventions would use the global Conventions attribute with
value "NUWG/Time_series", implying that this dataset adheres to the
NUWG conventions and also to the additional NUWG time-series
conventions. 
</dl>

<div class="node">
<p><hr>
<a name="NF90_005fPUT_005fATT"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fINQUIRE_005fATTRIBUTE">NF90_INQUIRE_ATTRIBUTE</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Attribute-Conventions">Attribute Conventions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Attributes">Attributes</a>
<br>
</div>

<h3 class="section">7.3 Create an Attribute: NF90_PUT_ATT</h3>

<p><a name="index-NF90_005fPUT_005fATT-144"></a><a name="index-NF90_005fPUT_005fATT_002c-example-145"></a>
The function NF90_PUT_ATTadds or changes a variable attribute or
global attribute of an open netCDF dataset. If this attribute is new,
or if the space required to store the attribute is greater than
before, the netCDF dataset must be in define mode.

<h3 class="heading">Usage</h3>

<p>Although it's possible to create attributes of all types, text and
double attributes are adequate for most purposes.

<pre class="example">      function nf90_put_att(ncid, varid, name, values)
        integer,            intent( in) :: ncid, varid
        character(len = *), intent( in) :: name
        any valid type, scalar or array of rank 1, &amp;
                            intent( in) :: values
        integer                         :: nf90_put_att
</pre>
     <dl>
<dt><code>ncid</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>varid</code><dd>Variable ID of the variable to which the attribute will be assigned or
NF90_GLOBAL for a global attribute.

     <br><dt><code>name</code><dd>Attribute name. Must begin with an alphabetic character, followed by
zero or more alphanumeric characters including the underscore
('_'). Case is significant. Attribute name conventions are assumed by
some netCDF generic applications, e.g., units as the name for a string
attribute that gives the units for a netCDF variable. For examples of
attribute conventions see <a href="#Attribute-Conventions">Attribute Conventions</a>.

     <br><dt><code>values</code><dd>An array of attribute values. Values may be supplied as scalars or as
arrays of rank one (one dimensional vectors). The external data type
of the attribute is set to match the internal representation of the
argument, that is if values is a two byte integer array, the attribute
will be of type NF90_INT2. Fortran 90 intrinsic functions can be used
to convert attributes to the desired type.

   </dl>

<h3 class="heading">Errors</h3>

<p>NF90_PUT_ATT returns the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:

     <ul>
<li>The variable ID is invalid for the specified netCDF dataset.

     <li>The specified netCDF type is invalid.

     <li>The specified length is negative.

     <li>The specified open netCDF dataset is in data mode and the specified
attribute would expand.

     <li>The specified open netCDF dataset is in data mode and the specified
attribute does not already exist.

     <li>The specified netCDF ID does not refer to an open netCDF dataset.

     <li>The number of attributes for this variable exceeds NF90_MAX_ATTRS.

   </ul>

<h3 class="heading">Example</h3>

<p>Here is an example using NF90_PUT_ATT to add a variable attribute
named valid_range for a netCDF variable named rh and a global
attribute named title to an existing netCDF dataset named foo.nc:

<pre class="example">      use netcdf
      implicit none
      integer :: ncid, status, RHVarID
      ...
      status = nf90_open("foo.nc", nf90_write, ncid)
      if (status /= nf90_noerr) call handle_err(status)
      ...
      ! Enter define mode so we can add the attribute
      status = nf90_redef(ncid)
      if (status /= nf90_noerr) call handle_err(status)
      ! Get the variable ID for "rh"...
      status = nf90_inq_varid(ncid, "rh", RHVarID)
      if (status /= nf90_noerr) call handle_err(status)
      ! ...  put the range attribute, setting it to eight byte reals...
      status = nf90_put_att(ncid, RHVarID, "valid_range", real((/ 0, 100 /))
      ! ... and the title attribute.
      if (status /= nf90_noerr) call handle_err(status)
      status = nf90_put_att(ncid, RHVarID, "title", "example netCDF dataset") )
      if (status /= nf90_noerr) call handle_err(status)
      ! Leave define mode
      status = nf90_enddef(ncid)
      if (status /= nf90_noerr) call handle_err(status)
</pre>
   <div class="node">
<p><hr>
<a name="NF90_005fINQUIRE_005fATTRIBUTE"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fGET_005fATT">NF90_GET_ATT</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fPUT_005fATT">NF90_PUT_ATT</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Attributes">Attributes</a>
<br>
</div>

<h3 class="section">7.4 Get Information about an Attribute: NF90_INQUIRE_ATTRIBUTE and NF90_INQ_ATTNAME</h3>

<p><a name="index-NF90_005fINQUIRE_005fATTRIBUTE-146"></a><a name="index-NF90_005fINQUIRE_005fATTRIBUTE_002c-example-147"></a><a name="index-NF90_005fINQ_005fATTNAME-148"></a><a name="index-NF90_005fINQ_005fATTNAME_002c-example-149"></a>
The function NF90_INQUIRE_ATTRIBUTE returns information about a netCDF
attribute given the variable ID and attribute name. Information about
an attribute includes its type, length, name, and number. See
NF90_GET_ATT for getting attribute values.

   <p>The function NF90_INQ_ATTNAME gets the name of an attribute, given its
variable ID and number. This function is useful in generic
applications that need to get the names of all the attributes
associated with a variable, since attributes are accessed by name
rather than number in all other attribute functions. The number of an
attribute is more volatile than the name, since it can change when
other attributes of the same variable are deleted. This is why an
attribute number is not called an attribute ID.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_inquire_attribute(ncid, varid, name, xtype, len, attnum)
        integer,             intent( in)           :: ncid, varid
        character (len = *), intent( in)           :: name
        integer,             intent(out), optional :: xtype, len, attnum
        integer                                    :: nf90_inquire_attribute
      function nf90_inq_attname(ncid, varid, attnum, name)
        integer,             intent( in) :: ncid, varid, attnum
        character (len = *), intent(out) :: name
        integer                          :: nf90_inq_attname
</pre>
     <dl>
<dt><code>ncid</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>varid</code><dd>Variable ID of the attribute's variable, or NF90_GLOBAL for a global
attribute.

     <br><dt><code>name</code><dd>Attribute name. For NF90_INQ_ATTNAME, this is a pointer to the location
for the returned attribute name.

     <br><dt><code>xtype</code><dd>Returned attribute type, one of the set of predefined netCDF external
data types. The valid netCDF external data types are NF90_BYTE, NF90_CHAR,
NF90_SHORT, NF90_INT, NF90_FLOAT, and NF90_DOUBLE.

     <br><dt><code>len</code><dd>Returned number of values currently stored in the attribute. For a
string-valued attribute, this is the number of characters in the
string.

     <br><dt><code>attnum</code><dd>For NF90_INQ_ATTNAME, the input attribute number; for NF90_INQ_ATTID, the
returned attribute number. The attributes for each variable are
numbered from 1 (the first attribute) to NATTS, where NATTS is the
number of attributes for the variable, as returned from a call to
NF90_INQ_VARNATTS.

     <p>(If you already know an attribute name, knowing its number is not very
useful, because accessing information about an attribute requires its
name.) 
</dl>

<h3 class="heading">Errors</h3>

<p>Each function returns the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
     <ul>
<li>The variable ID is invalid for the specified netCDF dataset.

     <li>The specified attribute does not exist.

     <li>The specified netCDF ID does not refer to an open netCDF dataset.

     <li>For NF90_INQ_ATTNAME, the specified attribute number is negative or more
than the number of attributes defined for the specified variable. 
</ul>

<h3 class="heading">Example</h3>

<p>Here is an example using NF90_INQUIRE_ATTRIBUTE to inquire about the lengths
of an attribute named valid_range for a netCDF variable named rh and a
global attribute named title in an existing netCDF dataset named
foo.nc:

<pre class="example">      use netcdf
      implicit none
      integer :: ncid, status
      integer :: RHVarID                       ! Variable ID
      integer :: validRangeLength, titleLength ! Attribute lengths
      ...
      status = nf90_open("foo.nc", nf90_nowrite, ncid)
      if (status /= nf90_noerr) call handle_err(status)
      ...
      ! Get the variable ID for "rh"...
      status = nf90_inq_varid(ncid, "rh", RHVarID)
      if (status /= nf90_noerr) call handle_err(status)
      ! ...  get the length of the "valid_range" attribute...
      status = nf90_inquire_attribute(ncid, RHVarID, "valid_range", &amp;
                                len = validRangeLength)
      if (status /= nf90_noerr) call handle_err(status)
      ! ... and the global title attribute.
      status = nf90_inquire_attribute(ncid, nf90_global, "title", len = titleLength)
      if (status /= nf90_noerr) call handle_err(status)
</pre>
   <div class="node">
<p><hr>
<a name="NF90_005fGET_005fATT"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fCOPY_005fATT">NF90_COPY_ATT</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fINQUIRE_005fATTRIBUTE">NF90_INQUIRE_ATTRIBUTE</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Attributes">Attributes</a>
<br>
</div>

<h3 class="section">7.5 Get Attribute's Values: NF90_GET_ATT</h3>

<p><a name="index-NF90_005fGET_005fATT-150"></a><a name="index-NF90_005fGET_005fATT_002c-example-151"></a>
Function nf90_get_att gets the value(s) of a netCDF attribute, given
its variable ID and name.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_get_att(ncid, varid, name, values)
        integer,            intent( in) :: ncid, varid
        character(len = *), intent( in) :: name
        any valid type, scalar or array of rank 1, &amp;
                            intent(out) :: values
        integer                         :: nf90_get_att
</pre>
     <dl>
<dt><code>ncid</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>varid</code><dd>Variable ID of the attribute's variable, or NF90_GLOBAL for a global attribute.

     <br><dt><code>name</code><dd>Attribute name.

     <br><dt><code>values</code><dd>Returned attribute values. All elements of the vector of attribute
values are returned, so you must provide enough space to hold them. If
you don't know how much space to reserve, call NF90_INQUIRE_ATTRIBUTE first
to find out the length of the attribute. If there is only a single
attribute values may be a scalar. If the attribute is of type
character values should be a variable of type character with the len
Fortran 90 attribute set to an appropriate value (i.e. character (len
= 80) :: values). You cannot read character data from a numeric
variable or numeric data from a text variable. For numeric data, if
the type of data differs from the netCDF variable type, type
conversion will occur. See <a href="netcdf.html#Type-Conversion">Type Conversion (NetCDF Users Guide)</a>.

   </dl>

<h3 class="heading">Errors</h3>

<p>NF90_GET_ATT_ type returns the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
     <ul>
<li>The variable ID is invalid for the specified netCDF dataset.

     <li>The specified attribute does not exist.

     <li>The specified netCDF ID does not refer to an open netCDF dataset.

     <li>One or more of the attribute values are out of the range of values
representable by the desired type. 
</ul>

<h3 class="heading">Example</h3>

<p>Here is an example using NF90_GET_ATT to determine the values of an
attribute named valid_range for a netCDF variable named rh and a
global attribute named title in an existing netCDF dataset named
foo.nc. In this example, it is assumed that we don't know how many
values will be returned, so we first inquire about the length of the
attributes to make sure we have enough space to store them:

<pre class="example">      use netcdf
      implicit none
      integer              :: ncid, status
      integer              :: RHVarID                       ! Variable ID
      integer              :: validRangeLength, titleLength ! Attribute lengths
      real, dimension(:), allocatable, &amp;
                           :: validRange
      character (len = 80) :: title
      ...
      status = nf90_open("foo.nc", nf90_nowrite, ncid)
      if (status /= nf90_noerr) call handle_err(status)
      ...
      ! Find the lengths of the attributes
      status = nf90_inq_varid(ncid, "rh", RHVarID)
      if (status /= nf90_noerr) call handle_err(status)
      status = nf90_inquire_attribute(ncid, RHVarID, "valid_range", &amp;
                                len = validRangeLength)
      if (status /= nf90_noerr) call handle_err(status)
      status = nf90_inquire_attribute(ncid, nf90_global, "title", len = titleLength)
      if (status /= nf90_noerr) call handle_err(status)
      ...
      !Allocate space to hold attribute values, check string lengths
      allocate(validRange(validRangeLength), stat = status)
      if(status /= 0 .or. len(title) &lt; titleLength)
        print *, "Not enough space to put attribute values."
        exit
      end if
      ! Read the attributes.
      status = nf90_get_att(ncid, RHVarID, "valid_range", validRange)
      if (status /= nf90_noerr) call handle_err(status)
      status = nf90_get_att(ncid, nf90_global, "title", title)
      if (status /= nf90_noerr) call handle_err(status)
</pre>
   <div class="node">
<p><hr>
<a name="NF90_005fCOPY_005fATT"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fRENAME_005fATT">NF90_RENAME_ATT</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fGET_005fATT">NF90_GET_ATT</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Attributes">Attributes</a>
<br>
</div>

<h3 class="section">7.6 Copy Attribute from One NetCDF to Another: NF90_COPY_ATT</h3>

<p><a name="index-NF90_005fCOPY_005fATT-152"></a><a name="index-NF90_005fCOPY_005fATT_002c-example-153"></a>
The function NF90_COPY_ATT copies an attribute from one open netCDF
dataset to another. It can also be used to copy an attribute from one
variable to another within the same netCDF dataset.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_copy_att(ncid_in, varid_in, name, ncid_out, varid_out)
        integer,             intent( in) :: ncid_in,  varid_in
        character (len = *), intent( in) :: name
        integer,             intent( in) :: ncid_out, varid_out
        integer                          :: nf90_copy_att
</pre>
     <dl>
<dt><code>ncid_in</code><dd>The netCDF ID of an input netCDF dataset from which the attribute
will be copied, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>varid_in</code><dd>ID of the variable in the input netCDF dataset from which the
attribute will be copied, or NF90_GLOBAL for a global attribute.

     <br><dt><code>name</code><dd>Name of the attribute in the input netCDF dataset to be copied.

     <br><dt><code>ncid_out</code><dd>The netCDF ID of the output netCDF dataset to which the attribute
will be copied, from a previous call to NF90_OPEN or NF90_CREATE. It is
permissible for the input and output netCDF IDs to be the same. The
output netCDF dataset should be in define mode if the attribute to be
copied does not already exist for the target variable, or if it would
cause an existing target attribute to grow.

     <br><dt><code>varid_out</code><dd>ID of the variable in the output netCDF dataset to which the
attribute will be copied, or NF90_GLOBAL to copy to a global attribute. 
</dl>

<h3 class="heading">Errors</h3>

<p>NF90_COPY_ATT returns the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:

     <ul>
<li>The input or output variable ID is invalid for the specified netCDF
dataset.

     <li>The specified attribute does not exist.

     <li>The output netCDF is not in define mode and the attribute is new for
the output dataset is larger than the existing attribute.

     <li>The input or output netCDF ID does not refer to an open netCDF
dataset. 
</ul>

<h3 class="heading">Example</h3>

<p>Here is an example using NF90_COPY_ATT to copy the variable attribute
units from the variable rh in an existing netCDF dataset named foo.nc
to the variable avgrh in another existing netCDF dataset named bar.nc,
assuming that the variable avgrh already exists, but does not yet have
a units attribute:

<pre class="example">      use netcdf
      implicit none
      integer :: ncid1, ncid2, status
      integer :: RHVarID, avgRHVarID    ! Variable ID
      ...
      status = nf90_open("foo.nc", nf90_nowrite, ncid1)
      if (status /= nf90_noerr) call handle_err(status)
      status = nf90_open("bar.nc", nf90_write, ncid2)
      if (status /= nf90_noerr) call handle_err(status)
      ...
      ! Find the IDs of the variables
      status = nf90_inq_varid(ncid1, "rh", RHVarID)
      if (status /= nf90_noerr) call handle_err(status)
      status = nf90_inq_varid(ncid1, "avgrh", avgRHVarID)
      if (status /= nf90_noerr) call handle_err(status)
      ...
      status = nf90_redef(ncid2)   ! Enter define mode
      if (status /= nf90_noerr) call handle_err(status)
      ! Copy variable attribute from "rh" in file 1 to "avgrh" in file 1
      status = nf90_copy_att(ncid1, RHVarID, "units", ncid2, avgRHVarID)
      if (status /= nf90_noerr) call handle_err(status)
      status = nf90_enddef(ncid2)
      if (status /= nf90_noerr) call handle_err(status)
</pre>
   <div class="node">
<p><hr>
<a name="NF90_005fRENAME_005fATT"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#NF90_005fDEL_005fATT">NF90_DEL_ATT</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fCOPY_005fATT">NF90_COPY_ATT</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Attributes">Attributes</a>
<br>
</div>

<h3 class="section">7.7 Rename an Attribute: NF90_RENAME_ATT</h3>

<p><a name="index-NF90_005fRENAME_005fATT-154"></a><a name="index-NF90_005fRENAME_005fATT_002c-example-155"></a>
The function NF90_RENAME_ATT changes the name of an attribute. If the
new name is longer than the original name, the netCDF dataset must be
in define mode. You cannot rename an attribute to have the same name
as another attribute of the same variable.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_rename_att(ncid, varid, curname, newname)
        integer,             intent( in) :: ncid,  varid
        character (len = *), intent( in) :: curname, newname
        integer                          :: nf90_rename_att
</pre>
     <dl>
<dt><code>ncid</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE

     <br><dt><code>varid</code><dd>ID of the attribute's variable, or NF90_GLOBAL for a global attribute

     <br><dt><code>curname</code><dd>The current attribute name.

     <br><dt><code>newname</code><dd>The new name to be assigned to the specified attribute. If the new
name is longer than the current name, the netCDF dataset must be in
define mode. 
</dl>

<h3 class="heading">Errors</h3>

<p>NF90_RENAME_ATT returns the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
     <ul>
<li>The specified variable ID is not valid.

     <li>The new attribute name is already in use for another attribute of the
specified variable.

     <li>The specified netCDF dataset is in data mode and the new name is
longer than the old name.

     <li>The specified attribute does not exist.

     <li>The specified netCDF ID does not refer to an open netCDF dataset. 
</ul>

<h3 class="heading">Example</h3>

<p>Here is an example using NF90_RENAME_ATT to rename the variable
attribute units to Units for a variable rh in an existing netCDF
dataset named foo.nc:

<pre class="example">      use netcdf
      implicit none
      integer :: ncid1, status
      integer :: RHVarID         ! Variable ID
      ...
      status = nf90_open("foo.nc", nf90_nowrite, ncid)
      if (status /= nf90_noerr) call handle_err(status)
      ...
      ! Find the IDs of the variables
      status = nf90_inq_varid(ncid, "rh", RHVarID)
      if (status /= nf90_noerr) call handle_err(status)
      ...
      status = nf90_rename_att(ncid, RHVarID, "units", "Units")
      if (status /= nf90_noerr) call handle_err(status)
</pre>
   <div class="node">
<p><hr>
<a name="NF90_005fDEL_005fATT"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#NF90_005fRENAME_005fATT">NF90_RENAME_ATT</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Attributes">Attributes</a>
<br>
</div>

<h3 class="section">7.8 NF90_DEL_ATT</h3>

<p><a name="index-NF90_005fDEL_005fATT-156"></a><a name="index-NF90_005fDEL_005fATT-_002c-example-157"></a>
The function NF90_DEL_ATT deletes a netCDF attribute from an open netCDF
dataset. The netCDF dataset must be in define mode.

<h3 class="heading">Usage</h3>

<pre class="example">      function nf90_del_att(ncid, varid, name)
        integer,             intent( in) :: ncid, varid
        character (len = *), intent( in) :: name
        integer                          :: nf90_del_att
</pre>
     <dl>
<dt><code>ncid</code><dd>NetCDF ID, from a previous call to NF90_OPEN or NF90_CREATE.

     <br><dt><code>varid</code><dd>ID of the attribute's variable, or NF90_GLOBAL for a global attribute.

     <br><dt><code>name</code><dd>The name of the attribute to be deleted. 
</dl>

<h3 class="heading">Errors</h3>

<p>NF90_DEL_ATT returns the value NF90_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:

     <ul>
<li>The specified variable ID is not valid.

     <li>The specified netCDF dataset is in data mode.

     <li>The specified attribute does not exist.

     <li>The specified netCDF ID does not refer to an open netCDF dataset. 
</ul>

<h3 class="heading">Example</h3>

<p>Here is an example using NF90_DEL_ATT to delete the variable attribute
Units for a variable rh in an existing netCDF dataset named foo.nc:

<pre class="example">      use netcdf
      implicit none
      integer :: ncid1, status
      integer :: RHVarID         ! Variable ID
      ...
      status = nf90_open("foo.nc", nf90_nowrite, ncid)
      if (status /= nf90_noerr) call handle_err(status)
      ...
      ! Find the IDs of the variables
      status = nf90_inq_varid(ncid, "rh", RHVarID)
      if (status /= nf90_noerr) call handle_err(status)
      ...
      status = nf90_redef(ncid)   ! Enter define mode
      if (status /= nf90_noerr) call handle_err(status)
      status = nf90_del_att(ncid, RHVarID, "Units")
      if (status /= nf90_noerr) call handle_err(status)
      status = nf90_enddef(ncid)
      if (status /= nf90_noerr) call handle_err(status)
</pre>
   <div class="node">
<p><hr>
<a name="Summary-of-Fortran-90-Interface"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#FORTRAN-77-to-Fortran-90-Transition-Guide">FORTRAN 77 to Fortran 90 Transition Guide</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Attributes">Attributes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="appendix">Appendix A Appendix A - Summary of Fortran 90 Interface</h2>

<p>Dataset Functions

<pre class="example">      function nf90_inq_libvers()
        character(len = 80) :: nf90_inq_libvers
      function nf90_strerror(ncerr)
        integer, intent( in) :: ncerr
        character(len = 80)  :: nf90_strerror
      function nf90_create(path, cmode, ncid)
        character (len = *), intent(in   ) :: path
        integer,             intent(in   ) :: cmode
        integer, optional,   intent(in   ) :: initialsize
        integer, optional,   intent(inout) :: chunksize
        integer,             intent(  out) :: ncid
        integer                            :: nf90_create
      function nf90_open(path, mode, ncid, chunksize)
        character (len = *), intent(in   ) :: path
        integer,             intent(in   ) :: mode
        integer,             intent(  out) :: ncid
        integer, optional,   intent(inout) :: chunksize
        integer                            :: nf90_open
      function nf90_set_fill(ncid, fillmode, old_mode)
        integer, intent( in) :: ncid, fillmode
        integer, intent(out) :: old_mode
        integer              :: nf90_set_fill
      function nf90_redef(ncid)
        integer, intent( in) :: ncid
        integer              :: nf90_redef
      function nf90_enddef(ncid, h_minfree, v_align, v_minfree, r_align)
        integer,           intent( in) :: ncid
        integer, optional, intent( in) :: h_minfree, v_align, v_minfree, r_align
        integer                        :: nf90_enddef
      function nf90_sync(ncid)
        integer, intent( in) :: ncid
        integer              :: nf90_sync
      function nf90_abort(ncid)
        integer, intent( in) :: ncid
        integer              :: nf90_abort
      function nf90_close(ncid)
        integer, intent( in) :: ncid
        integer              :: nf90_close
      function nf90_Inquire(ncid, nDimensions, nVariables, nAttributes, &amp;
                           unlimitedDimId)
        integer,           intent( in) :: ncid
        integer, optional, intent(out) :: nDimensions, nVariables, nAttributes, &amp;
                                    unlimitedDimId
        integer                        :: nf90_Inquire
</pre>
   <p>Dimension functions

<pre class="example">      function nf90_def_dim(ncid, name, len, dimid)
        integer,             intent( in) :: ncid
        character (len = *), intent( in) :: name
        integer,             intent( in) :: len
        integer,             intent(out) :: dimid
        integer                          :: nf90_def_dim
      function nf90_inq_dimid(ncid, name, dimid)
        integer,             intent( in) :: ncid
        character (len = *), intent( in) :: name
        integer,             intent(out) :: dimid
        integer                          :: nf90_inq_dimid
      function nf90_inquire_dimension(ncid, dimid, name, len)
        integer,                       intent( in) :: ncid, dimid
        character (len = *), optional, intent(out) :: name
        integer,             optional, intent(out) :: len
        integer                                    :: nf90_inquire_dimension
      function nf90_rename_dim(ncid, dimid, name)
        integer,             intent( in) :: ncid
        character (len = *), intent( in) :: name
        integer,             intent( in) :: dimid
        integer                          :: nf90_rename_dim
</pre>
   <p>Variable functions

<pre class="example">      function nf90_def_var(ncid, name, xtype, dimids, varid)
        integer,               intent( in) :: ncid
        character (len = *),   intent( in) :: name
        integer,               intent( in) :: xtype
        integer, dimension(:), intent( in) :: dimids ! May be omitted, scalar,
                                                  ! vector
        integer                            :: nf90_def_var
      function nf90_inq_varid(ncid, name, varid)
        integer,             intent( in) :: ncid
        character (len = *), intent( in) :: name
        integer,             intent(out) :: varid
        integer                          :: nf90_inq_varid
      function nf90_inquire_variable(ncid, varid, name, xtype, ndims, &amp;
                                     dimids, nAtts)
        integer,                         intent( in) :: ncid, varid
        character (len = *),   optional, intent(out) :: name
        integer,               optional, intent(out) :: xtype, ndims
        integer, dimension(*), optional, intent(out) :: dimids
        integer,               optional, intent(out) :: nAtts
        integer                                      :: nf90_inquire_variable
      function nf90_put_var(ncid, varid, values, start, stride, map)
        integer,                         intent( in) :: ncid, varid
        any valid type, scalar or array of any rank, &amp;
                                         intent( in) :: values
        integer, dimension(:), optional, intent( in) :: start, count, stride, map
        integer                                      :: nf90_put_var
      function nf90_get_var(ncid, varid, values, start, stride, map)
        integer,                         intent( in) :: ncid, varid
        any valid type, scalar or array of any rank, &amp;
                                         intent(out) :: values
        integer, dimension(:), optional, intent( in) :: start, count, stride, map
        integer                                      :: nf90_get_var
      function nf90_rename_var(ncid, varid, newname)
        integer,             intent( in) :: ncid, varid
        character (len = *), intent( in) :: newname
        integer                          :: nf90_rename_var
</pre>
   <p>Attribute functions

<pre class="example">      function nf90_inquire_attribute(ncid, varid, name, xtype, len, attnum)
        integer,             intent( in)           :: ncid, varid
        character (len = *), intent( in)           :: name
        integer,             intent(out), optional :: xtype, len, attnum
        integer                                    :: nf90_inquire_attribute
      function nf90_inq_attname(ncid, varid, attnum, name)
        integer,             intent( in) :: ncid, varid, attnum
        character (len = *), intent(out) :: name
        integer                          :: nf90_inq_attname
      function nf90_put_att(ncid, varid, name, values)
        integer,            intent( in) :: ncid, varid
        character(len = *), intent( in) :: name
        any valid type, scalar or array of rank 1, &amp;
                            intent( in) :: values
        integer                         :: nf90_put_att
      function nf90_get_att(ncid, varid, name, values)
        integer,            intent( in) :: ncid, varid
        character(len = *), intent( in) :: name
        any valid type, scalar or array of rank 1, &amp;
                            intent(out) :: values
        integer                          :: nf90_get_att
      function nf90_copy_att(ncid_in, varid_in, name, ncid_out, varid_out)
        integer,             intent( in) :: ncid_in,  varid_in
        character (len = *), intent( in) :: name
        integer,             intent( in) :: ncid_out, varid_out
        integer                          :: nf90_copy_att
      function nf90_rename_att(ncid, varid, curname, newname)
        integer,             intent( in) :: ncid,  varid
        character (len = *), intent( in) :: curname, newname
        integer                          :: nf90_rename_att
      function nf90_del_att(ncid, varid, name)
        integer,             intent( in) :: ncid, varid
        character (len = *), intent( in) :: name
        integer                          :: nf90_del_att
</pre>
   <div class="node">
<p><hr>
<a name="FORTRAN-77-to-Fortran-90-Transition-Guide"></a>Next:&nbsp;<a rel="next" accesskey="n" href="#Combined-Index">Combined Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Summary-of-Fortran-90-Interface">Summary of Fortran 90 Interface</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="appendix">Appendix B Appendix B - FORTRAN 77 to Fortran 90 Transition Guide</h2>

<h4 class="unnumberedsubsec">The new Fortran 90 interface</h4>

<p>The Fortran 90 interface to the netCDF library closely follows the
FORTRAN 77 interface. In most cases, function and constant names and
argument lists are the same, except that nf90_ replaces nf_ in
names. The Fortran 90 interface is much smaller than the FORTRAN 77
interface, however. This has been accomplished by using optional
arguments and overloaded functions wherever possible.

   <p>Because FORTRAN 77 is a subset of Fortran 90, there is no reason to
modify working FORTRAN code to use the Fortran 90 interface. New code,
however, can easily be patterned after existing FORTRAN while taking
advantage of the simpler interface. Some compilers may provide
additional support when using Fortran 90. For example, compilers may
issue warnings if arguments with intent( in) are not set before they
are passed to a procedure.

   <p>The Fortran 90 interface is currently implemented as a set of wrappers
around the base FORTRAN subroutines in the netCDF distribution. Future
versions may be implemented entirely in Fortran 90, adding additional
error checking possibilities.

<h4 class="unnumberedsubsec">Changes to Inquiry functions</h4>

<p>In the Fortran 90 interface there are two inquiry functions each for
dimensions, variables, and attributes, and a single inquiry function
for datasets. These functions take optional arguments, allowing users
to request only the information they need. These functions replace the
many-argument and single-argument inquiry functions in the FORTRAN
interface.

   <p>As an example, compare the attribute inquiry functions in the Fortran
90 interface

<pre class="example">      function nf90_inquire_attribute(ncid, varid, name, xtype, len, attnum)
        integer,             intent( in)           :: ncid, varid
        character (len = *), intent( in)           :: name
        integer,             intent(out), optional :: xtype, len, attnum
        integer                                    :: nf90_inquire_attribute
      function nf90_inq_attname(ncid, varid, attnum, name)
        integer,             intent( in) :: ncid, varid, attnum
        character (len = *), intent(out) :: name
        integer                          :: nf90_inq_attname
</pre>
   <p>with those in the FORTRAN interface

<pre class="example">      INTEGER FUNCTION  NF_INQ_ATT        (NCID, VARID, NAME, xtype, len)
      INTEGER FUNCTION  NF_INQ_ATTID      (NCID, VARID, NAME, attnum)
      INTEGER FUNCTION  NF_INQ_ATTTYPE    (NCID, VARID, NAME, xtype)
      INTEGER FUNCTION  NF_INQ_ATTLEN     (NCID, VARID, NAME, len)
      INTEGER FUNCTION  NF_INQ_ATTNAME    (NCID, VARID, ATTNUM, name)
</pre>
   <h4 class="unnumberedsubsec">Changes to put and get function</h4>

<p>The biggest simplification in the Fortran 90 is in the nf90_put_var
and nf90_get_var functions. Both functions are overloaded: the values
argument can be a scalar or an array any rank (7 is the maximum rank
allowed by Fortran 90), and may be of any numeric type or the default
character type. The netCDF library provides transparent conversion
between the external representation of the data and the desired
internal representation.

   <p>The start, count, stride, and map arguments to nf90_put_var and
nf90_get_var are optional. By default, data is read from or written to
consecutive values of starting at the origin of the netCDF variable;
the shape of the argument determines how many values are read from or
written to each dimension. Any or all of these arguments may be
supplied to override the default behavior.

   <p>Note also that Fortran 90 allows arbitrary array sections to be passed
to any procedure, which may greatly simplify programming. For examples
see <a href="#NF90_005fPUT_005fVAR">NF90_PUT_VAR</a> and <a href="#NF90_005fGET_005fVAR">NF90_GET_VAR</a>.

<div class="node">
<p><hr>
<a name="Combined-Index"></a>Previous:&nbsp;<a rel="previous" accesskey="p" href="#FORTRAN-77-to-Fortran-90-Transition-Guide">FORTRAN 77 to Fortran 90 Transition Guide</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="unnumbered">Index</h2>

<ul class="index-cp" compact>
<li><a href="#index-attributes_002c-adding-29">attributes, adding</a>: <a href="#Adding-New-Dimensions">Adding New Dimensions</a></li>
<li><a href="#index-big_002dendian-132">big-endian</a>: <a href="#NF90_005fDEF_005fVAR_005fENDIAN">NF90_DEF_VAR_ENDIAN</a></li>
<li><a href="#index-chunking-118">chunking</a>: <a href="#NF90_005fDEF_005fVAR_005fCHUNKING">NF90_DEF_VAR_CHUNKING</a></li>
<li><a href="#index-common-netcdf-commands-2">common netcdf commands</a>: <a href="#Use-of-the-NetCDF-Library">Use of the NetCDF Library</a></li>
<li><a href="#index-compiling-with-netCDF-library-34">compiling with netCDF library</a>: <a href="#Compiling-and-Linking-with-the-NetCDF-Library">Compiling and Linking with the NetCDF Library</a></li>
<li><a href="#index-compound-types_002c-overview-83">compound types, overview</a>: <a href="#Compound-Types">Compound Types</a></li>
<li><a href="#index-compression_002c-setting-parameters-124">compression, setting parameters</a>: <a href="#NF90_005fDEF_005fVAR_005fDEFLATE">NF90_DEF_VAR_DEFLATE</a></li>
<li><a href="#index-dataset_002c-creating-3">dataset, creating</a>: <a href="#Creating-a-NetCDF-Dataset">Creating a NetCDF Dataset</a></li>
<li><a href="#index-datasets_002c-overview-35">datasets, overview</a>: <a href="#Datasets-Introduction">Datasets Introduction</a></li>
<li><a href="#index-deflate-122">deflate</a>: <a href="#NF90_005fDEF_005fVAR_005fDEFLATE">NF90_DEF_VAR_DEFLATE</a></li>
<li><a href="#index-dimensions_002c-adding-27">dimensions, adding</a>: <a href="#Adding-New-Dimensions">Adding New Dimensions</a></li>
<li><a href="#index-endianness-131">endianness</a>: <a href="#NF90_005fDEF_005fVAR_005fENDIAN">NF90_DEF_VAR_ENDIAN</a></li>
<li><a href="#index-enum-type-109">enum type</a>: <a href="#Enum-Type">Enum Type</a></li>
<li><a href="#index-error-handling-31">error handling</a>: <a href="#Error-Handling">Error Handling</a></li>
<li><a href="#index-fletcher32-127">fletcher32</a>: <a href="#NF90_005fDEF_005fVAR_005fFLETCHER32">NF90_DEF_VAR_FLETCHER32</a></li>
<li><a href="#index-groups_002c-overview-57">groups, overview</a>: <a href="#Groups">Groups</a></li>
<li><a href="#index-interface-descriptions-36">interface descriptions</a>: <a href="#NetCDF-Library-Interface-Descriptions">NetCDF Library Interface Descriptions</a></li>
<li><a href="#index-linking-to-netCDF-library-33">linking to netCDF library</a>: <a href="#Compiling-and-Linking-with-the-NetCDF-Library">Compiling and Linking with the NetCDF Library</a></li>
<li><a href="#index-little_002dendian-133">little-endian</a>: <a href="#NF90_005fDEF_005fVAR_005fENDIAN">NF90_DEF_VAR_ENDIAN</a></li>
<li><a href="#index-NF90_005fABORT-53"><code>NF90_ABORT</code></a>: <a href="#NF90_005fABORT">NF90_ABORT</a></li>
<li><a href="#index-NF90_005fABORT-_002c-example-54">NF90_ABORT , example</a>: <a href="#NF90_005fABORT">NF90_ABORT</a></li>
<li><a href="#index-NF90_005fCLOSE-49"><code>NF90_CLOSE</code></a>: <a href="#NF90_005fCLOSE">NF90_CLOSE</a></li>
<li><a href="#index-NF90_005fCLOSE-_002c-example-50">NF90_CLOSE , example</a>: <a href="#NF90_005fCLOSE">NF90_CLOSE</a></li>
<li><a href="#index-NF90_005fCLOSE_002c-typical-use-10"><code>NF90_CLOSE, typical use</code></a>: <a href="#Creating-a-NetCDF-Dataset">Creating a NetCDF Dataset</a></li>
<li><a href="#index-NF90_005fCOPY_005fATT-152"><code>NF90_COPY_ATT</code></a>: <a href="#NF90_005fCOPY_005fATT">NF90_COPY_ATT</a></li>
<li><a href="#index-NF90_005fCOPY_005fATT_002c-example-153">NF90_COPY_ATT, example</a>: <a href="#NF90_005fCOPY_005fATT">NF90_COPY_ATT</a></li>
<li><a href="#index-NF90_005fCREATE-41"><code>NF90_CREATE</code></a>: <a href="#NF90_005fCREATE">NF90_CREATE</a></li>
<li><a href="#index-NF90_005fCREATE-_002c-example-42">NF90_CREATE , example</a>: <a href="#NF90_005fCREATE">NF90_CREATE</a></li>
<li><a href="#index-NF90_005fCREATE_002c-typical-use-4"><code>NF90_CREATE, typical use</code></a>: <a href="#Creating-a-NetCDF-Dataset">Creating a NetCDF Dataset</a></li>
<li><a href="#index-NF90_005fDEF_005fCOMPOUND-84"><code>NF90_DEF_COMPOUND</code></a>: <a href="#NF90_005fDEF_005fCOMPOUND">NF90_DEF_COMPOUND</a></li>
<li><a href="#index-NF90_005fDEF_005fDIM-67"><code>NF90_DEF_DIM</code></a>: <a href="#NF90_005fDEF_005fDIM">NF90_DEF_DIM</a></li>
<li><a href="#index-NF90_005fDEF_005fDIM_002c-example-68">NF90_DEF_DIM, example</a>: <a href="#NF90_005fDEF_005fDIM">NF90_DEF_DIM</a></li>
<li><a href="#index-NF90_005fDEF_005fDIM_002c-typical-use-5"><code>NF90_DEF_DIM, typical use</code></a>: <a href="#Creating-a-NetCDF-Dataset">Creating a NetCDF Dataset</a></li>
<li><a href="#index-NF90_005fDEF_005fENUM-110"><code>NF90_DEF_ENUM</code></a>: <a href="#NF90_005fDEF_005fENUM">NF90_DEF_ENUM</a></li>
<li><a href="#index-NF90_005fDEF_005fGRP-66"><code>NF90_DEF_GRP</code></a>: <a href="#NF90_005fDEF_005fGRP">NF90_DEF_GRP</a></li>
<li><a href="#index-NF90_005fDEF_005fOPAQUE-107"><code>NF90_DEF_OPAQUE</code></a>: <a href="#NF90_005fDEF_005fOPAQUE">NF90_DEF_OPAQUE</a></li>
<li><a href="#index-NF90_005fDEF_005fVAR-115"><code>NF90_DEF_VAR</code></a>: <a href="#NF90_005fDEF_005fVAR">NF90_DEF_VAR</a></li>
<li><a href="#index-NF90_005fDEF_005fVAR_002c-example-116">NF90_DEF_VAR, example</a>: <a href="#NF90_005fDEF_005fVAR">NF90_DEF_VAR</a></li>
<li><a href="#index-NF90_005fDEF_005fVAR_002c-typical-use-6"><code>NF90_DEF_VAR, typical use</code></a>: <a href="#Creating-a-NetCDF-Dataset">Creating a NetCDF Dataset</a></li>
<li><a href="#index-NF90_005fDEF_005fVAR_005fCHUNKING-117"><code>NF90_DEF_VAR_CHUNKING</code></a>: <a href="#NF90_005fDEF_005fVAR_005fCHUNKING">NF90_DEF_VAR_CHUNKING</a></li>
<li><a href="#index-NF90_005fDEF_005fVAR_005fDEFLATE-121"><code>NF90_DEF_VAR_DEFLATE</code></a>: <a href="#NF90_005fDEF_005fVAR_005fDEFLATE">NF90_DEF_VAR_DEFLATE</a></li>
<li><a href="#index-NF90_005fDEF_005fVAR_005fENDIAN-130"><code>NF90_DEF_VAR_ENDIAN</code></a>: <a href="#NF90_005fDEF_005fVAR_005fENDIAN">NF90_DEF_VAR_ENDIAN</a></li>
<li><a href="#index-NF90_005fDEF_005fVAR_005fFLETCHER32-126"><code>NF90_DEF_VAR_FLETCHER32</code></a>: <a href="#NF90_005fDEF_005fVAR_005fFLETCHER32">NF90_DEF_VAR_FLETCHER32</a></li>
<li><a href="#index-NF90_005fDEF_005fVLEN-100"><code>NF90_DEF_VLEN</code></a>: <a href="#NF90_005fDEF_005fVLEN">NF90_DEF_VLEN</a></li>
<li><a href="#index-NF90_005fDEL_005fATT-156"><code>NF90_DEL_ATT</code></a>: <a href="#NF90_005fDEL_005fATT">NF90_DEL_ATT</a></li>
<li><a href="#index-NF90_005fDEL_005fATT-_002c-example-157">NF90_DEL_ATT , example</a>: <a href="#NF90_005fDEL_005fATT">NF90_DEL_ATT</a></li>
<li><a href="#index-NF90_005fENDDEF-47"><code>NF90_ENDDEF</code></a>: <a href="#NF90_005fENDDEF">NF90_ENDDEF</a></li>
<li><a href="#index-NF90_005fENDDEF-_002c-example-48">NF90_ENDDEF , example</a>: <a href="#NF90_005fENDDEF">NF90_ENDDEF</a></li>
<li><a href="#index-NF90_005fENDDEF_002c-typical-use-8"><code>NF90_ENDDEF, typical use</code></a>: <a href="#Creating-a-NetCDF-Dataset">Creating a NetCDF Dataset</a></li>
<li><a href="#index-NF90_005fFREE_005fVLEN-104"><code>NF90_FREE_VLEN</code></a>: <a href="#NF90_005fFREE_005fVLEN">NF90_FREE_VLEN</a></li>
<li><a href="#index-NF90_005fGET_005fATT-150"><code>NF90_GET_ATT</code></a>: <a href="#NF90_005fGET_005fATT">NF90_GET_ATT</a></li>
<li><a href="#index-NF90_005fGET_005fATT_002c-example-151">NF90_GET_ATT, example</a>: <a href="#NF90_005fGET_005fATT">NF90_GET_ATT</a></li>
<li><a href="#index-NF90_005fGET_005fATT_002c-typical-use-22"><code>NF90_GET_ATT, typical use</code></a>: <a href="#Reading-a-netCDF-Dataset-with-Unknown-Names">Reading a netCDF Dataset with Unknown Names</a></li>
<li><a href="#index-NF90_005fGET_005fATT_002c-typical-use-14"><code>NF90_GET_ATT, typical use</code></a>: <a href="#Reading-a-NetCDF-Dataset-with-Known-Names">Reading a NetCDF Dataset with Known Names</a></li>
<li><a href="#index-NF90_005fGET_005fVAR-140"><code>NF90_GET_VAR</code></a>: <a href="#NF90_005fGET_005fVAR">NF90_GET_VAR</a></li>
<li><a href="#index-NF90_005fGET_005fVAR_002c-example-141">NF90_GET_VAR, example</a>: <a href="#NF90_005fGET_005fVAR">NF90_GET_VAR</a></li>
<li><a href="#index-NF90_005fGET_005fVAR_002c-typical-use-15"><code>NF90_GET_VAR, typical use</code></a>: <a href="#Reading-a-NetCDF-Dataset-with-Known-Names">Reading a NetCDF Dataset with Known Names</a></li>
<li><a href="#index-NF90_005fGET_005fVLEN_005fELEMENT-82"><code>NF90_GET_VLEN_ELEMENT</code></a>: <a href="#NF90_005fGET_005fVLEN_005fELEMENT">NF90_GET_VLEN_ELEMENT</a></li>
<li><a href="#index-NF90_005fINQ_005fATTNAME-148"><code>NF90_INQ_ATTNAME</code></a>: <a href="#NF90_005fINQUIRE_005fATTRIBUTE">NF90_INQUIRE_ATTRIBUTE</a></li>
<li><a href="#index-NF90_005fINQ_005fATTNAME_002c-example-149">NF90_INQ_ATTNAME, example</a>: <a href="#NF90_005fINQUIRE_005fATTRIBUTE">NF90_INQUIRE_ATTRIBUTE</a></li>
<li><a href="#index-NF90_005fINQ_005fATTNAME_002c-typical-use-21"><code>NF90_INQ_ATTNAME, typical use</code></a>: <a href="#Reading-a-netCDF-Dataset-with-Unknown-Names">Reading a netCDF Dataset with Unknown Names</a></li>
<li><a href="#index-NF90_005fINQ_005fCMP_005fFIELDDIM_005fSIZES-97"><code>NF90_INQ_CMP_FIELDDIM_SIZES</code></a>: <a href="#NF90_005fINQ_005fCOMPOUND_005fFIELD">NF90_INQ_COMPOUND_FIELD</a></li>
<li><a href="#index-NF90_005fINQ_005fCOMPOUND-87"><code>NF90_INQ_COMPOUND</code></a>: <a href="#NF90_005fINQ_005fCOMPOUND">NF90_INQ_COMPOUND</a></li>
<li><a href="#index-NF90_005fINQ_005fCOMPOUND_005fFIELD-91"><code>NF90_INQ_COMPOUND_FIELD</code></a>: <a href="#NF90_005fINQ_005fCOMPOUND_005fFIELD">NF90_INQ_COMPOUND_FIELD</a></li>
<li><a href="#index-NF90_005fINQ_005fCOMPOUND_005fFIELDINDEX-93"><code>NF90_INQ_COMPOUND_FIELDINDEX</code></a>: <a href="#NF90_005fINQ_005fCOMPOUND_005fFIELD">NF90_INQ_COMPOUND_FIELD</a></li>
<li><a href="#index-NF90_005fINQ_005fCOMPOUND_005fFIELDNAME-92"><code>NF90_INQ_COMPOUND_FIELDNAME</code></a>: <a href="#NF90_005fINQ_005fCOMPOUND_005fFIELD">NF90_INQ_COMPOUND_FIELD</a></li>
<li><a href="#index-NF90_005fINQ_005fCOMPOUND_005fFIELDNDIMS-96"><code>NF90_INQ_COMPOUND_FIELDNDIMS</code></a>: <a href="#NF90_005fINQ_005fCOMPOUND_005fFIELD">NF90_INQ_COMPOUND_FIELD</a></li>
<li><a href="#index-NF90_005fINQ_005fCOMPOUND_005fFIELDOFFSET-94"><code>NF90_INQ_COMPOUND_FIELDOFFSET</code></a>: <a href="#NF90_005fINQ_005fCOMPOUND_005fFIELD">NF90_INQ_COMPOUND_FIELD</a></li>
<li><a href="#index-NF90_005fINQ_005fCOMPOUND_005fFIELDTYPE-95"><code>NF90_INQ_COMPOUND_FIELDTYPE</code></a>: <a href="#NF90_005fINQ_005fCOMPOUND_005fFIELD">NF90_INQ_COMPOUND_FIELD</a></li>
<li><a href="#index-NF90_005fINQ_005fCOMPOUND_005fNAME-88"><code>NF90_INQ_COMPOUND_NAME</code></a>: <a href="#NF90_005fINQ_005fCOMPOUND">NF90_INQ_COMPOUND</a></li>
<li><a href="#index-NF90_005fINQ_005fCOMPOUND_005fNFIELDS-90"><code>NF90_INQ_COMPOUND_NFIELDS</code></a>: <a href="#NF90_005fINQ_005fCOMPOUND">NF90_INQ_COMPOUND</a></li>
<li><a href="#index-NF90_005fINQ_005fCOMPOUND_005fSIZE-89"><code>NF90_INQ_COMPOUND_SIZE</code></a>: <a href="#NF90_005fINQ_005fCOMPOUND">NF90_INQ_COMPOUND</a></li>
<li><a href="#index-NF90_005fINQ_005fDIMID-69"><code>NF90_INQ_DIMID</code></a>: <a href="#NF90_005fINQ_005fDIMID">NF90_INQ_DIMID</a></li>
<li><a href="#index-NF90_005fINQ_005fDIMID-_002c-example-70">NF90_INQ_DIMID , example</a>: <a href="#NF90_005fINQ_005fDIMID">NF90_INQ_DIMID</a></li>
<li><a href="#index-NF90_005fINQ_005fDIMID_002c-typical-use-12"><code>NF90_INQ_DIMID, typical use</code></a>: <a href="#Reading-a-NetCDF-Dataset-with-Known-Names">Reading a NetCDF Dataset with Known Names</a></li>
<li><a href="#index-NF90_005fINQ_005fDIMIDS-61"><code>NF90_INQ_DIMIDS</code></a>: <a href="#NF90_005fINQ_005fDIMIDS">NF90_INQ_DIMIDS</a></li>
<li><a href="#index-NF90_005fINQ_005fENUM-112"><code>NF90_INQ_ENUM</code></a>: <a href="#NF90_005fINQ_005fENUM">NF90_INQ_ENUM</a></li>
<li><a href="#index-NF90_005fINQ_005fENUM_005fIDENT-114"><code>NF90_INQ_ENUM_IDENT</code></a>: <a href="#NF90_005fINQ_005fENUM_005fIDENT">NF90_INQ_ENUM_IDENT</a></li>
<li><a href="#index-nf90_005finq_005fenum_005fmember-113"><code>nf90_inq_enum_member</code></a>: <a href="#NF90_005fINQ_005fENUM_005fMEMBER">NF90_INQ_ENUM_MEMBER</a></li>
<li><a href="#index-NF90_005fINQ_005fGRP_005fPARENT-65"><code>NF90_INQ_GRP_PARENT</code></a>: <a href="#NF90_005fINQ_005fGRP_005fPARENT">NF90_INQ_GRP_PARENT</a></li>
<li><a href="#index-NF90_005fINQ_005fGRPNAME-63"><code>NF90_INQ_GRPNAME</code></a>: <a href="#NF90_005fINQ_005fGRPNAME">NF90_INQ_GRPNAME</a></li>
<li><a href="#index-NF90_005fINQ_005fGRPNAME_005fFULL-64"><code>NF90_INQ_GRPNAME_FULL</code></a>: <a href="#NF90_005fINQ_005fGRPNAME_005fFULL">NF90_INQ_GRPNAME_FULL</a></li>
<li><a href="#index-NF90_005fINQ_005fGRPNAME_005fLEN-62"><code>NF90_INQ_GRPNAME_LEN</code></a>: <a href="#NF90_005fINQ_005fGRPNAME_005fLEN">NF90_INQ_GRPNAME_LEN</a></li>
<li><a href="#index-NF90_005fINQ_005fGRPS-59"><code>NF90_INQ_GRPS</code></a>: <a href="#NF90_005fINQ_005fGRPS">NF90_INQ_GRPS</a></li>
<li><a href="#index-NF90_005fINQ_005fLIBVERS-39"><code>NF90_INQ_LIBVERS</code></a>: <a href="#NF90_005fINQ_005fLIBVERS">NF90_INQ_LIBVERS</a></li>
<li><a href="#index-NF90_005fINQ_005fLIBVERS_002c-example-40">NF90_INQ_LIBVERS, example</a>: <a href="#NF90_005fINQ_005fLIBVERS">NF90_INQ_LIBVERS</a></li>
<li><a href="#index-NF90_005fINQ_005fNCID-58"><code>NF90_INQ_NCID</code></a>: <a href="#NF90_005fINQ_005fNCID">NF90_INQ_NCID</a></li>
<li><a href="#index-NF90_005fINQ_005fOPAQUE-108"><code>NF90_INQ_OPAQUE</code></a>: <a href="#NF90_005fINQ_005fOPAQUE">NF90_INQ_OPAQUE</a></li>
<li><a href="#index-NF90_005fINQ_005fTYPE-79"><code>NF90_INQ_TYPE</code></a>: <a href="#NF90_005fINQ_005fTYPE">NF90_INQ_TYPE</a></li>
<li><a href="#index-NF90_005fINQ_005fTYPEIDS-78"><code>NF90_INQ_TYPEIDS</code></a>: <a href="#NF90_005fINQ_005fTYPEIDS">NF90_INQ_TYPEIDS</a></li>
<li><a href="#index-NF90_005fINQ_005fUSER_005fTYPE-80"><code>NF90_INQ_USER_TYPE</code></a>: <a href="#NF90_005fINQ_005fUSER_005fTYPE">NF90_INQ_USER_TYPE</a></li>
<li><a href="#index-NF90_005fINQ_005fVAR_005fCHUNKING-120"><code>NF90_INQ_VAR_CHUNKING</code></a>: <a href="#NF90_005fINQ_005fVAR_005fCHUNKING">NF90_INQ_VAR_CHUNKING</a></li>
<li><a href="#index-NF90_005fINQ_005fVAR_005fDEFLATE-125"><code>NF90_INQ_VAR_DEFLATE</code></a>: <a href="#NF90_005fINQ_005fVAR_005fDEFLATE">NF90_INQ_VAR_DEFLATE</a></li>
<li><a href="#index-NF90_005fINQ_005fVAR_005fENDIAN-135"><code>NF90_INQ_VAR_ENDIAN</code></a>: <a href="#NF90_005fINQ_005fVAR_005fENDIAN">NF90_INQ_VAR_ENDIAN</a></li>
<li><a href="#index-NF90_005fINQ_005fVAR_005fFLETCHER32-129"><code>NF90_INQ_VAR_FLETCHER32</code></a>: <a href="#NF90_005fINQ_005fVAR_005fFLETCHER32">NF90_INQ_VAR_FLETCHER32</a></li>
<li><a href="#index-NF90_005fINQ_005fVARID_002c-typical-use-23"><code>NF90_INQ_VARID, typical use</code></a>: <a href="#Writing-Data-in-an-Existing-NetCDF-Dataset">Writing Data in an Existing NetCDF Dataset</a></li>
<li><a href="#index-NF90_005fINQ_005fVARID_002c-typical-use-13"><code>NF90_INQ_VARID, typical use</code></a>: <a href="#Reading-a-NetCDF-Dataset-with-Known-Names">Reading a NetCDF Dataset with Known Names</a></li>
<li><a href="#index-NF90_005fINQ_005fVARIDS-60"><code>NF90_INQ_VARIDS</code></a>: <a href="#NF90_005fINQ_005fVARIDS">NF90_INQ_VARIDS</a></li>
<li><a href="#index-NF90_005fINQ_005fVLEN-102"><code>NF90_INQ_VLEN</code></a>: <a href="#NF90_005fINQ_005fVLEN">NF90_INQ_VLEN</a></li>
<li><a href="#index-NF90_005fINQUIRE_002c-typical-use-17"><code>NF90_INQUIRE, typical use</code></a>: <a href="#Reading-a-netCDF-Dataset-with-Unknown-Names">Reading a netCDF Dataset with Unknown Names</a></li>
<li><a href="#index-NF90_005fINQUIRE_005fATTRIBUTE-146"><code>NF90_INQUIRE_ATTRIBUTE</code></a>: <a href="#NF90_005fINQUIRE_005fATTRIBUTE">NF90_INQUIRE_ATTRIBUTE</a></li>
<li><a href="#index-NF90_005fINQUIRE_005fATTRIBUTE_002c-example-147">NF90_INQUIRE_ATTRIBUTE, example</a>: <a href="#NF90_005fINQUIRE_005fATTRIBUTE">NF90_INQUIRE_ATTRIBUTE</a></li>
<li><a href="#index-NF90_005fINQUIRE_005fATTRIBUTE_002c-typical-use-20"><code>NF90_INQUIRE_ATTRIBUTE, typical use</code></a>: <a href="#Reading-a-netCDF-Dataset-with-Unknown-Names">Reading a netCDF Dataset with Unknown Names</a></li>
<li><a href="#index-NF90_005fINQUIRE_005fDIMENSION-71"><code>NF90_INQUIRE_DIMENSION</code></a>: <a href="#NF90_005fINQUIRE_005fDIMENSION">NF90_INQUIRE_DIMENSION</a></li>
<li><a href="#index-NF90_005fINQUIRE_005fDIMENSION-_002c-example-72">NF90_INQUIRE_DIMENSION , example</a>: <a href="#NF90_005fINQUIRE_005fDIMENSION">NF90_INQUIRE_DIMENSION</a></li>
<li><a href="#index-NF90_005fINQUIRE_005fDIMENSION_002c-typical-use-18"><code>NF90_INQUIRE_DIMENSION, typical use</code></a>: <a href="#Reading-a-netCDF-Dataset-with-Unknown-Names">Reading a netCDF Dataset with Unknown Names</a></li>
<li><a href="#index-NF90_005fINQUIRE_005fVARIABLE-136"><code>NF90_INQUIRE_VARIABLE</code></a>: <a href="#NF90_005fINQUIRE_005fVARIABLE">NF90_INQUIRE_VARIABLE</a></li>
<li><a href="#index-NF90_005fINQUIRE_005fVARIABLE-_002c-example-137">NF90_INQUIRE_VARIABLE , example</a>: <a href="#NF90_005fINQUIRE_005fVARIABLE">NF90_INQUIRE_VARIABLE</a></li>
<li><a href="#index-NF90_005fINQUIRE_005fVARIABLE_002c-typical-use-19"><code>NF90_INQUIRE_VARIABLE, typical use</code></a>: <a href="#Reading-a-netCDF-Dataset-with-Unknown-Names">Reading a netCDF Dataset with Unknown Names</a></li>
<li><a href="#index-NF90_005fINSERT_005fARRAY_005fCOMPOUND-86"><code>NF90_INSERT_ARRAY_COMPOUND</code></a>: <a href="#NF90_005fINSERT_005fARRAY_005fCOMPOUND">NF90_INSERT_ARRAY_COMPOUND</a></li>
<li><a href="#index-NF90_005fINSERT_005fCOMPOUND-85"><code>NF90_INSERT_COMPOUND</code></a>: <a href="#NF90_005fINSERT_005fCOMPOUND">NF90_INSERT_COMPOUND</a></li>
<li><a href="#index-NF90_005fINSERT_005fENUM-111"><code>NF90_INSERT_ENUM</code></a>: <a href="#NF90_005fINSERT_005fENUM">NF90_INSERT_ENUM</a></li>
<li><a href="#index-NF90_005fOPEN-43"><code>NF90_OPEN</code></a>: <a href="#NF90_005fOPEN">NF90_OPEN</a></li>
<li><a href="#index-NF90_005fOPEN-_002c-example-44">NF90_OPEN , example</a>: <a href="#NF90_005fOPEN">NF90_OPEN</a></li>
<li><a href="#index-NF90_005fOPEN_002c-typical-use-11"><code>NF90_OPEN, typical use</code></a>: <a href="#Reading-a-NetCDF-Dataset-with-Known-Names">Reading a NetCDF Dataset with Known Names</a></li>
<li><a href="#index-NF90_005fPUT_005fATT-144"><code>NF90_PUT_ATT</code></a>: <a href="#NF90_005fPUT_005fATT">NF90_PUT_ATT</a></li>
<li><a href="#index-NF90_005fPUT_005fATT_002c-example-145">NF90_PUT_ATT, example</a>: <a href="#NF90_005fPUT_005fATT">NF90_PUT_ATT</a></li>
<li><a href="#index-NF90_005fPUT_005fATT_002c-typical-use-25"><code>NF90_PUT_ATT, typical use</code></a>: <a href="#Writing-Data-in-an-Existing-NetCDF-Dataset">Writing Data in an Existing NetCDF Dataset</a></li>
<li><a href="#index-NF90_005fPUT_005fATT_002c-typical-use-7"><code>NF90_PUT_ATT, typical use</code></a>: <a href="#Creating-a-NetCDF-Dataset">Creating a NetCDF Dataset</a></li>
<li><a href="#index-NF90_005fPUT_005fVAR-138"><code>NF90_PUT_VAR</code></a>: <a href="#NF90_005fPUT_005fVAR">NF90_PUT_VAR</a></li>
<li><a href="#index-NF90_005fPUT_005fVAR_002c-example-139">NF90_PUT_VAR, example</a>: <a href="#NF90_005fPUT_005fVAR">NF90_PUT_VAR</a></li>
<li><a href="#index-NF90_005fPUT_005fVAR_002c-typical-use-24"><code>NF90_PUT_VAR, typical use</code></a>: <a href="#Writing-Data-in-an-Existing-NetCDF-Dataset">Writing Data in an Existing NetCDF Dataset</a></li>
<li><a href="#index-NF90_005fPUT_005fVAR_002c-typical-use-9"><code>NF90_PUT_VAR, typical use</code></a>: <a href="#Creating-a-NetCDF-Dataset">Creating a NetCDF Dataset</a></li>
<li><a href="#index-NF90_005fPUT_005fVLEN_005fELEMENT-81"><code>NF90_PUT_VLEN_ELEMENT</code></a>: <a href="#NF90_005fPUT_005fVLEN_005fELEMENT">NF90_PUT_VLEN_ELEMENT</a></li>
<li><a href="#index-NF90_005fREDEF-45"><code>NF90_REDEF</code></a>: <a href="#NF90_005fREDEF">NF90_REDEF</a></li>
<li><a href="#index-NF90_005fREDEF-_002c-example-46">NF90_REDEF , example</a>: <a href="#NF90_005fREDEF">NF90_REDEF</a></li>
<li><a href="#index-NF90_005fREDEF_002c-typical-use-30"><code>NF90_REDEF, typical use</code></a>: <a href="#Adding-New-Dimensions">Adding New Dimensions</a></li>
<li><a href="#index-NF90_005fRENAME_005fATT-154"><code>NF90_RENAME_ATT</code></a>: <a href="#NF90_005fRENAME_005fATT">NF90_RENAME_ATT</a></li>
<li><a href="#index-NF90_005fRENAME_005fATT_002c-example-155">NF90_RENAME_ATT, example</a>: <a href="#NF90_005fRENAME_005fATT">NF90_RENAME_ATT</a></li>
<li><a href="#index-NF90_005fRENAME_005fDIM-73"><code>NF90_RENAME_DIM</code></a>: <a href="#NF90_005fRENAME_005fDIM">NF90_RENAME_DIM</a></li>
<li><a href="#index-NF90_005fRENAME_005fDIM-_002c-example-74">NF90_RENAME_DIM , example</a>: <a href="#NF90_005fRENAME_005fDIM">NF90_RENAME_DIM</a></li>
<li><a href="#index-NF90_005fRENAME_005fVAR-142"><code>NF90_RENAME_VAR</code></a>: <a href="#NF90_005fRENAME_005fVAR">NF90_RENAME_VAR</a></li>
<li><a href="#index-NF90_005fRENAME_005fVAR-_002c-example-143">NF90_RENAME_VAR , example</a>: <a href="#NF90_005fRENAME_005fVAR">NF90_RENAME_VAR</a></li>
<li><a href="#index-NF90_005fSET_005fFILL-55"><code>NF90_SET_FILL</code></a>: <a href="#NF90_005fSET_005fFILL">NF90_SET_FILL</a></li>
<li><a href="#index-NF90_005fSET_005fFILL-_002c-example-56">NF90_SET_FILL , example</a>: <a href="#NF90_005fSET_005fFILL">NF90_SET_FILL</a></li>
<li><a href="#index-NF90_005fSTRERROR-37"><code>NF90_STRERROR</code></a>: <a href="#NF90_005fSTRERROR">NF90_STRERROR</a></li>
<li><a href="#index-NF90_005fSTRERROR_002c-example-38">NF90_STRERROR, example</a>: <a href="#NF90_005fSTRERROR">NF90_STRERROR</a></li>
<li><a href="#index-NF90_005fSTRERROR_002c-introduction-32"><code>NF90_STRERROR, introduction</code></a>: <a href="#Error-Handling">Error Handling</a></li>
<li><a href="#index-NF90_005fSYNC-51"><code>NF90_SYNC</code></a>: <a href="#NF90_005fSYNC">NF90_SYNC</a></li>
<li><a href="#index-NF90_005fSYNC-_002c-example-52">NF90_SYNC , example</a>: <a href="#NF90_005fSYNC">NF90_SYNC</a></li>
<li><a href="#index-opaque-type-106">opaque type</a>: <a href="#Opaque-Type">Opaque Type</a></li>
<li><a href="#index-reading-dataset-with-unknown-names-16">reading dataset with unknown names</a>: <a href="#Reading-a-netCDF-Dataset-with-Unknown-Names">Reading a netCDF Dataset with Unknown Names</a></li>
<li><a href="#index-user-defined-types-76">user defined types</a>: <a href="#User-Defined-Data-Types">User Defined Data Types</a></li>
<li><a href="#index-user-defined-types_002c-overview-77">user defined types, overview</a>: <a href="#User-Defined-Types">User Defined Types</a></li>
<li><a href="#index-users_0027-guide_002c-netcdf-1">users' guide, netcdf</a>: <a href="#Use-of-the-NetCDF-Library">Use of the NetCDF Library</a></li>
<li><a href="#index-variable-length-array-type_002c-overview-75">variable length array type, overview</a>: <a href="#User-Defined-Data-Types">User Defined Data Types</a></li>
<li><a href="#index-variable-length-arrays-98">variable length arrays</a>: <a href="#Variable-Length-Array">Variable Length Array</a></li>
<li><a href="#index-variables_002c-adding-28">variables, adding</a>: <a href="#Adding-New-Dimensions">Adding New Dimensions</a></li>
<li><a href="#index-variables_002c-chunking-119">variables, chunking</a>: <a href="#NF90_005fDEF_005fVAR_005fCHUNKING">NF90_DEF_VAR_CHUNKING</a></li>
<li><a href="#index-variables_002c-endian-134">variables, endian</a>: <a href="#NF90_005fDEF_005fVAR_005fENDIAN">NF90_DEF_VAR_ENDIAN</a></li>
<li><a href="#index-variables_002c-fletcher32-128">variables, fletcher32</a>: <a href="#NF90_005fDEF_005fVAR_005fFLETCHER32">NF90_DEF_VAR_FLETCHER32</a></li>
<li><a href="#index-variables_002c-setting-deflate-123">variables, setting deflate</a>: <a href="#NF90_005fDEF_005fVAR_005fDEFLATE">NF90_DEF_VAR_DEFLATE</a></li>
<li><a href="#index-VLEN-99">VLEN</a>: <a href="#Variable-Length-Array">Variable Length Array</a></li>
<li><a href="#index-VLEN_002c-defining-105">VLEN, defining</a>: <a href="#NF90_005fFREE_005fVLEN">NF90_FREE_VLEN</a></li>
<li><a href="#index-VLEN_002c-defining-103">VLEN, defining</a>: <a href="#NF90_005fINQ_005fVLEN">NF90_INQ_VLEN</a></li>
<li><a href="#index-VLEN_002c-defining-101">VLEN, defining</a>: <a href="#NF90_005fDEF_005fVLEN">NF90_DEF_VLEN</a></li>
<li><a href="#index-writing-to-existing-dataset-26">writing to existing dataset</a>: <a href="#Writing-Data-in-an-Existing-NetCDF-Dataset">Writing Data in an Existing NetCDF Dataset</a></li>
</ul></body></html>

